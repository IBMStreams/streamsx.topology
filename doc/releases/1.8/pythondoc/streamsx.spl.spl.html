

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>streamsx.spl.spl module &mdash; streamsx 1.8.2 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="streamsx 1.8.2 documentation" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> streamsx
          

          
          </a>

          
            
            
              <div class="version">
                1.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <!-- Local TOC -->
                <div class="local-toc"><ul>
<li><a class="reference internal" href="#">streamsx.spl.spl module</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#python-classes-as-spl-operators">Python classes as SPL operators</a><ul>
<li><a class="reference internal" href="#id1">Overview</a></li>
<li><a class="reference internal" href="#operator-state">Operator state</a></li>
<li><a class="reference internal" href="#operator-initialization-shutdown">Operator initialization &amp; shutdown</a></li>
<li><a class="reference internal" href="#application-log-and-trace">Application log and trace</a></li>
</ul>
</li>
<li><a class="reference internal" href="#python-functions-as-spl-operators">Python functions as SPL operators</a></li>
<li><a class="reference internal" href="#processing-spl-tuples-in-python">Processing SPL tuples in Python</a><ul>
<li><a class="reference internal" href="#id2">Overview</a></li>
<li><a class="reference internal" href="#tuple-passing-styles">Tuple Passing Styles</a><ul>
<li><a class="reference internal" href="#dictionary">Dictionary</a></li>
<li><a class="reference internal" href="#tuple">Tuple</a></li>
<li><a class="reference internal" href="#attributes-by-name">Attributes by name</a></li>
<li><a class="reference internal" href="#attributes-by-position">Attributes by position</a></li>
<li><a class="reference internal" href="#selecting-the-style">Selecting the style</a></li>
</ul>
</li>
<li><a class="reference internal" href="#submission-of-spl-tuples-from-python">Submission of SPL tuples from Python</a><ul>
<li><a class="reference internal" href="#none">None</a></li>
<li><a class="reference internal" href="#python-tuple">Python tuple</a></li>
<li><a class="reference internal" href="#python-dictionary">Python dictionary</a></li>
<li><a class="reference internal" href="#python-list">Python list</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">streamsx</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>streamsx.spl.spl module</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/streamsx.spl.spl.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-streamsx.spl.spl">
<span id="streamsx-spl-spl-module"></span><h1>streamsx.spl.spl module<a class="headerlink" href="#module-streamsx.spl.spl" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>SPL primitive operators that call a Python function or
class methods are created by decorators provided by this module.</p>
<p>The name of the function or callable class becomes the name of the
operator.</p>
<p>Once created the operators become part of a toolkit and may be used
like any other SPL operator.</p>
<p>A decorated function is a stateless operator while a decorated class
is an optionally stateful operator.</p>
<p>These are the supported decorators that create an SPL operator:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#streamsx.spl.spl.source" title="streamsx.spl.spl.source"><code class="xref py py-class docutils literal"><span class="pre">&#64;spl.source</span></code></a> - Creates a source operator that produces tuples.</li>
<li><a class="reference internal" href="#streamsx.spl.spl.filter" title="streamsx.spl.spl.filter"><code class="xref py py-class docutils literal"><span class="pre">&#64;spl.filter</span></code></a> - Creates a operator that filters tuples.</li>
<li><a class="reference internal" href="#streamsx.spl.spl.map" title="streamsx.spl.spl.map"><code class="xref py py-class docutils literal"><span class="pre">&#64;spl.map</span></code></a> - Creates a operator that maps input tuples to output tuples.</li>
<li><a class="reference internal" href="#streamsx.spl.spl.for_each" title="streamsx.spl.spl.for_each"><code class="xref py py-class docutils literal"><span class="pre">&#64;spl.for_each</span></code></a> - Creates a operator that terminates a stream processing each tuple.</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#streamsx.spl.spl.primitive_operator" title="streamsx.spl.spl.primitive_operator"><code class="xref py py-class docutils literal"><span class="pre">&#64;spl.primitive_operator</span></code></a> - Creates an SPL primitive operator that</dt>
<dd>has an an arbitrary number of input and output ports.</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="python-classes-as-spl-operators">
<h2>Python classes as SPL operators<a class="headerlink" href="#python-classes-as-spl-operators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Overview<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Decorating a Python class creates a stateful SPL operator
where the instance fields of the class are the operator&#8217;s state. An instance
of the class is created when the SPL operator invocation is initialized
at SPL runtime. The instance of the Python class is private to the SPL
operator and is maintained for the lifetime of the operator.</p>
<p>If the class has instance fields then they are the state of the
operator and are private to each invocation of the operator.</p>
<p>If the <cite>__init__</cite> method has parameters beyond the first
<cite>self</cite> parameter then they are mapped to operator parameters.
Any parameter that has a default value becomes an optional parameter
to the SPL operator. Parameters of the form <cite>*args</cite> and <cite>**kwargs</cite>
are not supported.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Parameter names must be valid SPL identifers,
SPL identifiers start with an ASCII letter or underscore,
followed by ASCII letters, digits, or underscores.
The name also must not be an SPL keyword.</p>
<p class="last">Parameter names <code class="docutils literal"><span class="pre">suppress</span></code> and <code class="docutils literal"><span class="pre">include</span></code> are reserved.</p>
</div>
<p>The value of the operator parameters at SPL operator invocation are passed
to the <cite>__init__</cite> method. This is equivalent to creating an instance
of the class passing the operator parameters into the constructor.</p>
<p>For example, with this decorated class producing an SPL source
operator:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">source</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">Range</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span>

  <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">))</span>
</pre></div>
</div>
<p>The SPL operator <cite>Range</cite> has two parameters, <cite>stop</cite> is mandatory and <cite>start</cite> is optional, defaulting to zero. Thus the SPL operator may be invoked as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>// Produces the sequence of values from 0 to 99
//
// Creates an instance of the Python class
// Range using Range(100)
//
stream&lt;int32 seq&gt; R = Range() {
  param
    stop: 100;
}
</pre></div>
</div>
<p>or both operator parameters can be set:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>// Produces the sequence of values from 50 to 74
//
// Creates an instance of the Python class
// Range using Range(75, 50)
//
stream&lt;int32 seq&gt; R = Range() {
  param
    start: 50;
    stop: 75;
}
</pre></div>
</div>
</div>
<div class="section" id="operator-state">
<h3>Operator state<a class="headerlink" href="#operator-state" title="Permalink to this headline">¶</a></h3>
<p>Use of a class allows the operator to be stateful by maintaining state in instance
attributes across invocations (tuple processing).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For future compatibility instances of a class should ensure that the object&#8217;s
state can be pickled. See <a class="reference external" href="https://docs.python.org/3.5/library/pickle.html#handling-stateful-objects">https://docs.python.org/3.5/library/pickle.html#handling-stateful-objects</a></p>
</div>
</div>
<div class="section" id="operator-initialization-shutdown">
<h3>Operator initialization &amp; shutdown<a class="headerlink" href="#operator-initialization-shutdown" title="Permalink to this headline">¶</a></h3>
<p>Execution of an instance for an operator effectively run in a context manager so that an instance&#8217;s <code class="docutils literal"><span class="pre">__enter__</span></code>
method is called when the processing element containing the operator is initialized
and its <code class="docutils literal"><span class="pre">__exit__</span></code> method called when the processing element is stopped. To take advantage of this
the class must define both <code class="docutils literal"><span class="pre">__enter__</span></code> and <code class="docutils literal"><span class="pre">__exit__</span></code> methods.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For future compatibility operator initialization such as opening files should be in <code class="docutils literal"><span class="pre">__enter__</span></code>
in order to support stateful operator restart &amp; checkpointing in the future.</p>
</div>
<p>Example of using <code class="docutils literal"><span class="pre">__enter__</span></code> and <code class="docutils literal"><span class="pre">__exit__</span></code> to open and close a file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">streamsx.ec</span> <span class="k">as</span> <span class="nn">ec</span>

<span class="nd">@spl</span><span class="o">.</span><span class="n">map</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">Sentiment</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="application-log-and-trace">
<h3>Application log and trace<a class="headerlink" href="#application-log-and-trace" title="Permalink to this headline">¶</a></h3>
<p>IBM Streams provides application trace and log services which are
accesible through standard Python loggers from the <cite>logging</cite> module.</p>
<p>See <a class="reference internal" href="streamsx.ec.html#streams-app-log-trc"><span class="std std-ref">Application log and trace</span></a>.</p>
</div>
</div>
<div class="section" id="python-functions-as-spl-operators">
<h2>Python functions as SPL operators<a class="headerlink" href="#python-functions-as-spl-operators" title="Permalink to this headline">¶</a></h2>
<p>Decorating a Python function creates a stateless SPL operator.
In SPL terms this is similar to an SPL Custom operator, where
the code in the Python function is the custom code. For
operators with input ports the function is called for each
input tuple, passing a Python representation of the SPL input tuple.
For an SPL source operator the function is called to obtain an iterable
whose contents will be submitted to the output stream as SPL tuples.</p>
<p>Operator parameters are not supported.</p>
<p>An example SPL sink operator that prints each input SPL tuple after
its conversion to a Python tuple:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">for_each</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">PrintTuple</span><span class="p">(</span><span class="o">*</span><span class="n">tuple_</span><span class="p">):</span>
    <span class="s2">&quot;Print each tuple to standard out.&quot;</span>
     <span class="nb">print</span><span class="p">(</span><span class="n">tuple_</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="processing-spl-tuples-in-python">
<span id="spl-tuple-to-python"></span><h2>Processing SPL tuples in Python<a class="headerlink" href="#processing-spl-tuples-in-python" title="Permalink to this headline">¶</a></h2>
<p>SPL tuples are converted to Python objects and passed to a decorated callable.</p>
<div class="section" id="id2">
<h3>Overview<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>For each SPL tuple arriving at an input port a Python function is called with
the SPL tuple converted to Python values suitable for the function call.
How the tuple is passed is defined by the tuple passing style.</p>
</div>
<div class="section" id="tuple-passing-styles">
<h3>Tuple Passing Styles<a class="headerlink" href="#tuple-passing-styles" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>An input tuple can be passed to Python function using a number of different styles:</dt>
<dd><ul class="first last simple">
<li><em>dictionary</em></li>
<li><em>tuple</em></li>
<li><em>attributes by name</em> <strong>not yet implemented</strong></li>
<li><em>attributes by position</em></li>
</ul>
</dd>
</dl>
<div class="section" id="dictionary">
<h4>Dictionary<a class="headerlink" href="#dictionary" title="Permalink to this headline">¶</a></h4>
<p>Passing the SPL tuple as a Python dictionary is flexible
and makes the operator independent of any schema.
A disadvantage is the reduction in code readability
for Python function by not having formal parameters,
though getters such as <code class="docutils literal"><span class="pre">tuple['id']</span></code> mitigate that to some extent.
If the function is general purpose and can derive meaning
from the keys that are the attribute names then <code class="docutils literal"><span class="pre">**kwargs</span></code> can be useful.</p>
<p>When the only function parameter is <code class="docutils literal"><span class="pre">**kwargs</span></code>
(e.g. <code class="docutils literal"><span class="pre">def</span> <span class="pre">myfunc(**tuple_):</span></code>) then the passing style is <em>dictionary</em>.</p>
<p>All of the attributes are passed in the dictionary
using the SPL schema attribute name as the key.</p>
</div>
<div class="section" id="tuple">
<h4>Tuple<a class="headerlink" href="#tuple" title="Permalink to this headline">¶</a></h4>
<p>Passing the SPL tuple as a Python tuple is flexible
and makes the operator independent of any schema
but is brittle to changes in the SPL schema.
Another disadvantage is the reduction in code readability
for Python function by not having formal parameters.
However if the function is general purpose and independent
of the tuple contents <code class="docutils literal"><span class="pre">*args</span></code> can be useful.</p>
<p>When the only function parameter is <code class="docutils literal"><span class="pre">*args</span></code>
(e.g. <code class="docutils literal"><span class="pre">def</span> <span class="pre">myfunc(*tuple_):</span></code>) then the passing style is <em>tuple</em>.</p>
<p>All of the attributes are passed as a Python tuple
with the order of values matching the order of the SPL schema.</p>
</div>
<div class="section" id="attributes-by-name">
<h4>Attributes by name<a class="headerlink" href="#attributes-by-name" title="Permalink to this headline">¶</a></h4>
<p>(<strong>not yet implemented</strong>)</p>
<p>Passing attributes by name can be robust against changes
in the SPL scheme, e.g. additional attributes being added in
the middle of the schema, but does require that the SPL schema
has matching attribute names.</p>
<p>When <em>attributes by name</em> is used then SPL tuple attributes
are passed to the function by name for formal parameters.
Order of the attributes and parameters need not match.
This is supported for function parameters of
kind <code class="docutils literal"><span class="pre">POSITIONAL_OR_KEYWORD</span></code> and <code class="docutils literal"><span class="pre">KEYWORD_ONLY</span></code>.</p>
<p>If the function signature also contains a parameter of the form
<code class="docutils literal"><span class="pre">**kwargs</span></code> (<code class="docutils literal"><span class="pre">VAR_KEYWORD</span></code>) then any attributes not bound to
formal parameters are passed in its dictionary using the
SPL schema attribute name as the key.</p>
<p>If the function signature also contains an arbitrary argument
list <code class="docutils literal"><span class="pre">*args</span></code> then any attributes not bound to formal parameters
or to <code class="docutils literal"><span class="pre">**kwargs</span></code> are passed in order of the SPL schema.</p>
<p>If there are only formal parameters any non-bound attributes
are not passed into the function.</p>
</div>
<div class="section" id="attributes-by-position">
<h4>Attributes by position<a class="headerlink" href="#attributes-by-position" title="Permalink to this headline">¶</a></h4>
<p>Passing attributes by position allows the SPL operator to
be independent of the SPL schema but is brittle to
changes in the SPL schema. For example a function expecting
an identifier and a sensor reading as the first two attributes
would break if an attribute representing region was added as
the first SPL attribute.</p>
<p>When <em>attributes by position</em> is used then SPL tuple attributes are
passed to the function by position for formal parameters.
The first SPL attribute in the tuple is passed as the first parameter.
This is supported for function parameters of kind <cite>POSITIONAL_OR_KEYWORD</cite>.</p>
<p>If the function signature also contains an arbitrary argument
list <cite>*args</cite> (<cite>VAR_POSITIONAL</cite>) then any attributes not bound
to formal parameters are passed in order of the SPL schema.</p>
<p>The function signature must not contain a parameter of the form
<code class="docutils literal"><span class="pre">**kwargs</span></code> (<cite>VAR_KEYWORD</cite>).</p>
<p>If there are only formal parameters any non-bound attributes
are not passed into the function.</p>
<p>The SPL schema must have at least the number of positional arguments
the function requires.</p>
</div>
<div class="section" id="selecting-the-style">
<h4>Selecting the style<a class="headerlink" href="#selecting-the-style" title="Permalink to this headline">¶</a></h4>
<p>For signatures only containing a parameter of the form
<code class="docutils literal"><span class="pre">*args</span></code> or <code class="docutils literal"><span class="pre">**kwargs</span></code> the style is implicitly defined:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">def</span> <span class="pre">f(**tuple_)</span></code> - <em>dictionary</em> - <code class="docutils literal"><span class="pre">tuple_</span></code> will contain a dictionary of all of the SPL tuple attribute&#8217;s values with the keys being the attribute names.</li>
<li><code class="docutils literal"><span class="pre">def</span> <span class="pre">f(*tuple_)</span></code> - <em>tuple</em> - <code class="docutils literal"><span class="pre">tuple_</span></code> will contain all of the SPL tuple attribute&#8217;s values in order of the SPL schema definition.</li>
</ul>
</div></blockquote>
<p>Otherwise the style is set by the <code class="docutils literal"><span class="pre">style</span></code> parameter to the decorator,
defaulting to <em>attributes by name</em>. The style value can be set to:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">'name'</span></code> - <em>attributes by name</em> (the default)</li>
<li><code class="docutils literal"><span class="pre">'position'</span></code> - <em>attributes by position</em></li>
</ul>
</div></blockquote>
<p><strong>Note</strong>: For backwards compatibility <code class="docutils literal"><span class="pre">&#64;spl.pipe</span></code> and <code class="docutils literal"><span class="pre">&#64;spl.sink</span></code>
<strong>always</strong> use <em>attributes by position</em> and do not support <code class="docutils literal"><span class="pre">**kwargs</span></code>.
They do not support the <code class="docutils literal"><span class="pre">style</span></code> parameter.</p>
<p class="rubric">Examples</p>
<p>These examples show how an SPL tuple with the schema and value:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">tuple</span><span class="o">&lt;</span><span class="n">rstring</span> <span class="nb">id</span><span class="p">,</span> <span class="n">float64</span> <span class="n">temp</span><span class="p">,</span> <span class="n">boolean</span> <span class="n">increase</span><span class="o">&gt;</span>
<span class="p">{</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;battery&#39;</span><span class="p">,</span> <span class="n">temp</span><span class="o">=</span><span class="mf">23.7</span><span class="p">,</span> <span class="n">increase</span><span class="o">=</span><span class="n">true</span><span class="p">}</span>
</pre></div>
</div>
<p>is passed into a variety of functions by showing the effective Python
call and the resulting values of the function&#8217;s parameters.</p>
<p><em>Dictionary</em> consuming all attributes by <code class="docutils literal"><span class="pre">**kwargs</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">map</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">**</span><span class="n">tuple_</span><span class="p">)</span>
    <span class="k">pass</span>
<span class="c1"># f({&#39;id&#39;:&#39;battery&#39;, &#39;temp&#39;:23.7, &#39;increase&#39;: True})</span>
<span class="c1">#     tuple_={&#39;id&#39;:&#39;battery&#39;, &#39;temp&#39;:23.7, &#39;increase&#39;:True}</span>
</pre></div>
</div>
<p><em>Tuple</em> consuming all attributes by <code class="docutils literal"><span class="pre">*args</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">map</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">*</span><span class="n">tuple_</span><span class="p">)</span>
    <span class="k">pass</span>
<span class="c1"># f(&#39;battery&#39;, 23.7, True)</span>
<span class="c1">#     tuple_=(&#39;battery&#39;,23.7, True)</span>
</pre></div>
</div>
<p><em>Attributes by name</em> consuming all attributes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">map</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">increase</span><span class="p">)</span>
    <span class="k">pass</span>
<span class="c1"># f(id=&#39;battery&#39;, temp=23.7, increase=True)</span>
<span class="c1">#     id=&#39;battery&#39;</span>
<span class="c1">#     temp=23.7</span>
<span class="c1">#     increase=True</span>
</pre></div>
</div>
<p><em>Attributes by name</em> consuming a subset of attributes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">map</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>
    <span class="k">pass</span>
<span class="c1"># f(id=&#39;battery&#39;, temp=23.7)</span>
<span class="c1">#    id=&#39;battery&#39;</span>
<span class="c1">#    temp=23.7</span>
</pre></div>
</div>
<p><em>Attributes by name</em> consuming a subset of attributes in a different order:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">map</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">increase</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>
    <span class="k">pass</span>
<span class="c1"># f(temp=23.7, increase=True)</span>
<span class="c1">#    increase=True</span>
<span class="c1">#    temp=23.7</span>
</pre></div>
</div>
<p><em>Attributes by name</em> consuming <cite>id</cite> by name and remaining attributes by <code class="docutils literal"><span class="pre">**kwargs</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">map</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="o">**</span><span class="n">tuple_</span><span class="p">)</span>
    <span class="k">pass</span>
<span class="c1"># f(id=&#39;battery&#39;, {&#39;temp&#39;:23.7, &#39;increase&#39;:True})</span>
<span class="c1">#    id=&#39;battery&#39;</span>
<span class="c1">#    tuple_={&#39;temp&#39;:23.7, &#39;increase&#39;:True}</span>
</pre></div>
</div>
<p><em>Attributes by name</em> consuming <cite>id</cite> by name and remaining attributes by <code class="docutils literal"><span class="pre">*args</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">map</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="o">*</span><span class="n">tuple_</span><span class="p">)</span>
    <span class="k">pass</span>
<span class="c1"># f(id=&#39;battery&#39;, 23.7, True)</span>
<span class="c1">#    id=&#39;battery&#39;</span>
<span class="c1">#    tuple_=(23.7, True)</span>
</pre></div>
</div>
<p><em>Attributes by position</em> consuming all attributes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;position&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">up</span><span class="p">)</span>
     <span class="k">pass</span>
<span class="c1"># f(&#39;battery&#39;, 23.7, True)</span>
<span class="c1">#    key=&#39;battery&#39;</span>
<span class="c1">#    value=23.7</span>
<span class="c1">#    up=True</span>
</pre></div>
</div>
<p><em>Attributes by position</em> consuming a subset of attributes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;position&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
   <span class="k">pass</span>
<span class="c1"># f(&#39;battery&#39;, 23.7)</span>
<span class="c1">#    a=&#39;battery&#39;</span>
<span class="c1">#    b=23.7</span>
</pre></div>
</div>
<p><em>Attributes by position</em> consuming <cite>id</cite> by position and remaining attributes by <code class="docutils literal"><span class="pre">*args</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;position&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">tuple_</span><span class="p">)</span>
    <span class="k">pass</span>
<span class="c1"># f(&#39;battery&#39;, 23.7, True)</span>
<span class="c1">#    key=&#39;battery&#39;</span>
<span class="c1">#    tuple_=(23.7, True)</span>
</pre></div>
</div>
<p>In all cases the SPL tuple must be able to provide all parameters
required by the function. If the SPL schema is insufficient then
an error will result, typically an SPL compile time error.</p>
<p>The SPL schema can provide a subset of the formal parameters if the
remaining attributes are optional (having a default).</p>
<p><em>Attributes by name</em> consuming a subset of attributes with an optional parameter not matched by the schema:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">map</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">pressure</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
   <span class="k">pass</span>
<span class="c1"># f(id=&#39;battery&#39;, temp=23.7)</span>
<span class="c1">#     id=&#39;battery&#39;</span>
<span class="c1">#     temp=23.7</span>
<span class="c1">#     pressure=None</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="submission-of-spl-tuples-from-python">
<span id="submit-from-python"></span><h3>Submission of SPL tuples from Python<a class="headerlink" href="#submission-of-spl-tuples-from-python" title="Permalink to this headline">¶</a></h3>
<p>The return from a decorated callable results in submission of SPL tuples
on the associated outut port.</p>
<dl class="docutils">
<dt>A Python function must return:</dt>
<dd><ul class="first last simple">
<li><code class="docutils literal"><span class="pre">None</span></code></li>
<li>a Python tuple</li>
<li>a Python dictionary</li>
<li>a list containing any of the above.</li>
</ul>
</dd>
</dl>
<div class="section" id="none">
<h4>None<a class="headerlink" href="#none" title="Permalink to this headline">¶</a></h4>
<p>When <code class="docutils literal"><span class="pre">None</span></code> is return then no tuple will be submitted to
the operator output port.</p>
</div>
<div class="section" id="python-tuple">
<h4>Python tuple<a class="headerlink" href="#python-tuple" title="Permalink to this headline">¶</a></h4>
<p>When a Python tuple is returned it is converted to an SPL tuple and
submitted to the output port.</p>
<p>The values of a Python tuple are assigned to an output SPL tuple by position,
so the first value in the Python tuple is assigned to the first attribute
in the SPL tuple:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># SPL input schema: tuple&lt;int32 x, float64 y&gt;</span>
<span class="c1"># SPL output schema: tuple&lt;int32 x, float64 y, float32 z&gt;</span>
<span class="nd">@spl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;position&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
   <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>

<span class="c1"># The SPL output will be:</span>
<span class="c1"># All values explictly set by returned Python tuple</span>
<span class="c1"># based on the x,y values from the input tuple</span>
<span class="c1"># x is set to: x</span>
<span class="c1"># y is set to: y</span>
<span class="c1"># z is set to: x+y</span>
</pre></div>
</div>
<p>The returned tuple may be <em>sparse</em>, any attribute value in the tuple
that is <code class="docutils literal"><span class="pre">None</span></code> will be set to their SPL default or copied from the
input tuple, depending on the operator kind:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># SPL input schema: tuple&lt;int32 x, float64 x&gt;</span>
<span class="c1"># SPL output schema: tuple&lt;int32 x, float64 y, float32 z&gt;</span>
<span class="nd">@spl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;position&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
   <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>

<span class="c1"># The SPL output will be:</span>
<span class="c1"># x is set to: x (explictly set by returned Python tuple)</span>
<span class="c1"># y is set to: y (set by matching input SPL attribute)</span>
<span class="c1"># z is set to: x+y</span>
</pre></div>
</div>
<p>When a returned tuple has less values than attributes in the SPL output
schema the attributes not set by the Python function will be set
to their SPL default or copied from the input tuple, depending on
the operator kind:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># SPL input schema: tuple&lt;int32 x, float64 x&gt;</span>
<span class="c1"># SPL output schema: tuple&lt;int32 x, float64 y, float32 z&gt;</span>
<span class="nd">@spl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;position&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">a</span><span class="p">,</span>

<span class="c1"># The SPL output will be:</span>
<span class="c1"># x is set to: x (explictly set by returned Python tuple)</span>
<span class="c1"># y is set to: y (set by matching input SPL attribute)</span>
<span class="c1"># z is set to: 0 (default int32 value)</span>
</pre></div>
</div>
<p>When a returned tuple has more values than attributes in the SPL output schema then the additional values are ignored:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># SPL input schema: tuple&lt;int32 x, float64 x&gt;</span>
<span class="c1"># SPL output schema: tuple&lt;int32 x, float64 y, float32 z&gt;</span>
<span class="nd">@spl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;position&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
   <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="p">)</span>

<span class="c1"># The SPL output will be:</span>
<span class="c1"># All values explictly set by returned Python tuple</span>
<span class="c1"># based on the x,y values from the input tuple</span>
<span class="c1"># x is set to: x</span>
<span class="c1"># y is set to: y</span>
<span class="c1"># z is set to: x+y</span>
<span class="c1">#</span>
<span class="c1"># The fourth value in the tuple a/b = x/y is ignored.</span>
</pre></div>
</div>
</div>
<div class="section" id="python-dictionary">
<h4>Python dictionary<a class="headerlink" href="#python-dictionary" title="Permalink to this headline">¶</a></h4>
<p>A Python dictionary is converted to an SPL tuple for submission to
the associated output port. An SPL attribute is set from the
dictionary if the dictionary contains a key equal to the attribute
name. The value is used to set the attribute, unless the attribute is
<code class="docutils literal"><span class="pre">None</span></code>.</p>
<p>If the value in the dictionary is <code class="docutils literal"><span class="pre">None</span></code> or no matching key exists
then the attribute value is set from a mathing (name and type)
attribute in the input tuple or to its
default value depending on the operator kind.</p>
<p>Any keys in the dictionary that do not map to SPL attribute names are ignored.</p>
</div>
<div class="section" id="python-list">
<h4>Python list<a class="headerlink" href="#python-list" title="Permalink to this headline">¶</a></h4>
<p>When a list is returned, each value is converted to an SPL tuple and
submitted to the output port, in order of the list starting with the
first element (position 0). If the list contains <cite>None</cite> at an index
then no SPL tuple is submitted for that index.</p>
<p>The list must only contain Python tuples, dictionaries or <cite>None</cite>. The list
can contain a mix of valid values.</p>
<p>The list may be empty resulting in no tuples being submitted.</p>
<dl class="class">
<dt id="streamsx.spl.spl.PrimitiveOperator">
<em class="property">class </em><code class="descclassname">streamsx.spl.spl.</code><code class="descname">PrimitiveOperator</code><a class="headerlink" href="#streamsx.spl.spl.PrimitiveOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Primitive operator super class.
Classes decorated with <cite>&#64;spl.primitive_operator</cite> must extend
this class if they have one or more output ports. This class
provides the <cite>submit</cite> method to submit tuples to specified
otuput port.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.</span></p>
</div>
<dl class="method">
<dt id="streamsx.spl.spl.PrimitiveOperator.all_ports_ready">
<code class="descname">all_ports_ready</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.spl.spl.PrimitiveOperator.all_ports_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>Notifcation that the operator can submit tuples.</p>
<p>Called when the primitive operator can submit tuples
using <a class="reference internal" href="#streamsx.spl.spl.PrimitiveOperator.submit" title="streamsx.spl.spl.PrimitiveOperator.submit"><code class="xref py py-meth docutils literal"><span class="pre">submit()</span></code></a>. An operator must not submit
tuples until this method is called or until a port
processing method is called.</p>
<p>Any implementation must not block. A typical use
is to start threads that submit tuples.</p>
<p>An implementation must return a value that allows
the SPL runtime to determine when an operator completes.
An operator completes, and finalizes its output ports
when:</p>
<blockquote>
<div><ul class="simple">
<li>All input ports (if any) have been finalized.</li>
<li>All background processing is complete.</li>
</ul>
</div></blockquote>
<p>The return from <code class="docutils literal"><span class="pre">all_ports_ready</span></code> defines when
background processing, such as threads started by
<code class="docutils literal"><span class="pre">all_ports_ready</span></code>, is complete. The value is one of:</p>
<blockquote>
<div><ul class="simple">
<li>A value that evaluates to <cite>False</cite> - No background processing exists.</li>
<li>A value that evaluates to <cite>True</cite> - Background processing exists and never completes. E.g. a source operator that processes real time events.</li>
<li>A callable - Background processing is complete when the callable returns. The SPL runtime invokes the callable once (passing no arguments) when the method returns background processing is assumed to be complete.</li>
</ul>
</div></blockquote>
<p>For example if an implementation starts a single thread then <cite>Thread.join</cite> is returned to complete the operator when the thread completes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">all_ports_ready</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">submitter</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_and_submit_data</span><span class="p">)</span>
    <span class="n">submitter</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">submitter</span><span class="o">.</span><span class="n">join</span>

<span class="k">def</span> <span class="nf">_find_and_submit_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Value indicating active background processing.</td>
</tr>
</tbody>
</table>
<p>This method implementation does nothing and returns <code class="docutils literal"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="streamsx.spl.spl.PrimitiveOperator.submit">
<code class="descname">submit</code><span class="sig-paren">(</span><em>port_id</em>, <em>tuple_</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.spl.spl.PrimitiveOperator.submit" title="Permalink to this definition">¶</a></dt>
<dd><p>Submit a tuple to the output port.</p>
<p>The value to be submitted (<code class="docutils literal"><span class="pre">tuple_</span></code>) can be a <code class="docutils literal"><span class="pre">None</span></code> (nothing will be submitted),
<code class="docutils literal"><span class="pre">tuple</span></code>, <code class="docutils literal"><span class="pre">dict`</span> <span class="pre">or</span> <span class="pre">``list</span></code> of those types. For details
on how the <code class="docutils literal"><span class="pre">tuple_</span></code> is mapped to an SPL tuple see <a class="reference internal" href="#submit-from-python"><span class="std std-ref">Submission of SPL tuples from Python</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>port_id</strong> &#8211; Identifier of the port specified in the
<code class="docutils literal"><span class="pre">output_ports</span></code> parameter of the <code class="docutils literal"><span class="pre">&#64;spl.primitive_operator</span></code>
decorator.</li>
<li><strong>tuple</strong> &#8211; Tuple (or tuples) to be submitted to the output port.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="streamsx.spl.spl.filter">
<em class="property">class </em><code class="descclassname">streamsx.spl.spl.</code><code class="descname">filter</code><span class="sig-paren">(</span><em>style=None</em>, <em>docpy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.spl.spl.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Decorator that creates a filter SPL operator from a callable class or function.</p>
<p>A filter SPL operator has a single input port and one mandatory
and one optional output port. The schema of each output port
must match the input port. For each tuple on the input port the
callable is called passing the contents of the tuple. if the
function returns a value that evaluates to True then it is
submitted to mandatory output port 0. Otherwise it it submitted to
the second optional output port (1) or discarded if the port is
not specified in the SPL invocation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>style</strong> &#8211; How the SPL tuple is passed into Python callable or function, see  <a class="reference internal" href="#spl-tuple-to-python"><span class="std std-ref">Processing SPL tuples in Python</span></a>.</li>
<li><strong>docpy</strong> &#8211; Copy Python docstrings into SPL operator model for SPLDOC.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Example definition:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">filter</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">AttribThreshold</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter based upon a single attribute being</span>
<span class="sd">    above a threshold.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="n">attr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">tuple_</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tuple_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">:</span>
</pre></div>
</div>
<p>Example SPL invocation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">stream</span><span class="o">&lt;</span><span class="n">rstring</span> <span class="nb">id</span><span class="p">,</span> <span class="n">float64</span> <span class="n">voltage</span><span class="o">&gt;</span> <span class="n">Sensors</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">stream</span><span class="o">&lt;</span><span class="n">Sensors</span><span class="o">&gt;</span> <span class="n">InterestingSensors</span> <span class="o">=</span> <span class="n">AttribThreshold</span><span class="p">(</span><span class="n">Sensors</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">param</span>
      <span class="n">attr</span><span class="p">:</span> <span class="s2">&quot;voltage&quot;</span><span class="p">;</span>
      <span class="n">threshold</span><span class="p">:</span> <span class="mf">225.0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="streamsx.spl.spl.for_each">
<em class="property">class </em><code class="descclassname">streamsx.spl.spl.</code><code class="descname">for_each</code><span class="sig-paren">(</span><em>style=None</em>, <em>docpy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.spl.spl.for_each" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Creates an SPL operator with a single input port.</p>
<p>A SPL operator with a single input port and no output ports.
For each tuple on the input port the decorated callable
is called passing the contents of the tuple.</p>
<p>Example definition:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">for_each</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">PrintTuple</span><span class="p">(</span><span class="o">*</span><span class="n">tuple_</span><span class="p">):</span>
<span class="sd">&quot;&quot;&quot;Print each tuple to standard out.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tuple_</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Example SPL invocation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">()</span> <span class="k">as</span> <span class="n">PT</span> <span class="o">=</span> <span class="n">PrintTuple</span><span class="p">(</span><span class="n">SensorReadings</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>style</strong> &#8211; How the SPL tuple is passed into Python callable, see  <a class="reference internal" href="#spl-tuple-to-python"><span class="std std-ref">Processing SPL tuples in Python</span></a>.</li>
<li><strong>docpy</strong> &#8211; Copy Python docstrings into SPL operator model for SPLDOC.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="streamsx.spl.spl.ignore">
<code class="descclassname">streamsx.spl.spl.</code><code class="descname">ignore</code><span class="sig-paren">(</span><em>wrapped</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.spl.spl.ignore" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to ignore a Python function.</p>
<p>If a Python callable is decorated with <code class="docutils literal"><span class="pre">&#64;spl.ignore</span></code>
then function is ignored by <code class="docutils literal"><span class="pre">spl-python-extract.py</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>wrapped</strong> &#8211; Function that will be ignored.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="streamsx.spl.spl.input_port">
<em class="property">class </em><code class="descclassname">streamsx.spl.spl.</code><code class="descname">input_port</code><span class="sig-paren">(</span><em>style=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.spl.spl.input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Declare an input port and its processor method.</p>
<p>Instance methods within a class decorated by
<a class="reference internal" href="#streamsx.spl.spl.primitive_operator" title="streamsx.spl.spl.primitive_operator"><code class="xref py py-class docutils literal"><span class="pre">spl.primitive_operator</span></code></a> declare
input ports by decorating methods with this decorator.</p>
<p>Each tuple arriving on the input port will result in a call
to the processor method passing the stream tuple converted to
a Python representation depending on the style. The style is
determined by the method signature or the <cite>style</cite> parameter,
see  <a class="reference internal" href="#spl-tuple-to-python"><span class="std std-ref">Processing SPL tuples in Python</span></a>.</p>
<p>The order of the methods within the class define
the order of the ports, so the first port is
the first method decorated with <cite>input_port</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>style</strong> &#8211; How the SPL tuple is passed into the method, see  <a class="reference internal" href="#spl-tuple-to-python"><span class="std std-ref">Processing SPL tuples in Python</span></a>.</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="streamsx.spl.spl.map">
<em class="property">class </em><code class="descclassname">streamsx.spl.spl.</code><code class="descname">map</code><span class="sig-paren">(</span><em>style=None</em>, <em>docpy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.spl.spl.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Decorator to create a map SPL operator from a callable class or function.</p>
<p>Creates an SPL operator with a single input port and a single
output port. For each tuple on the input port the
callable is called passing the contents of the tuple.</p>
<p>The value returned from the callable results in
zero or more tuples being submitted to the operator output
port, see <a class="reference internal" href="#submit-from-python"><span class="std std-ref">Submission of SPL tuples from Python</span></a>.</p>
<p>Example definition:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">map</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">AddSeq</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="sd">&quot;&quot;&quot;Add a sequence number as the last attribute.&quot;&quot;&quot;</span>
<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">tuple_</span><span class="p">):</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">tuple_</span> <span class="o">+</span> <span class="p">(</span><span class="nb">id</span><span class="p">,)</span>
</pre></div>
</div>
<p>Example SPL invocation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">stream</span><span class="o">&lt;</span><span class="n">In</span><span class="p">,</span> <span class="nb">tuple</span><span class="o">&lt;</span><span class="n">uint64</span> <span class="n">seq</span><span class="o">&gt;&gt;</span> <span class="n">InWithSeq</span> <span class="o">=</span> <span class="n">AddSeq</span><span class="p">(</span><span class="n">In</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>style</strong> &#8211; How the SPL tuple is passed into Python callable or function, see  <a class="reference internal" href="#spl-tuple-to-python"><span class="std std-ref">Processing SPL tuples in Python</span></a>.</li>
<li><strong>docpy</strong> &#8211; Copy Python docstrings into SPL operator model for SPLDOC.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="streamsx.spl.spl.pipe">
<code class="descclassname">streamsx.spl.spl.</code><code class="descname">pipe</code><span class="sig-paren">(</span><em>wrapped</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.spl.spl.pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to create an SPL operator from a function.</p>
<p>A pipe SPL operator with a single input port and a single
output port. For each tuple on the input port the
function is called passing the contents of the tuple.</p>
<p>SPL attributes from the tuple are passed by position.</p>
<p>The value returned from the function results in
zero or more tuples being submitted to the operator output
port, see <a class="reference internal" href="#submit-from-python"><span class="std std-ref">Submission of SPL tuples from Python</span></a>.</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 1.8: </span>Recommended to use <a class="reference internal" href="#streamsx.spl.spl.map" title="streamsx.spl.spl.map"><code class="xref py py-class docutils literal"><span class="pre">&#64;spl.map</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="streamsx.spl.spl.primitive_operator">
<em class="property">class </em><code class="descclassname">streamsx.spl.spl.</code><code class="descname">primitive_operator</code><span class="sig-paren">(</span><em>output_ports=None</em>, <em>docpy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.spl.spl.primitive_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Creates an SPL primitive operator with an arbitrary number of input ports and
output ports.</p>
<p>Input ports are declared by decorating an instance method
with <a class="reference internal" href="#streamsx.spl.spl.input_port" title="streamsx.spl.spl.input_port"><code class="xref py py-meth docutils literal"><span class="pre">input_port()</span></code></a>. The method is the process method
for the input port and is called for each tuple that arrives
at the port. The order of the decorated process methods defines
the order of the ports in the SPL operator, with the first
process method being the first port at index zero.</p>
<p>Output ports are declared by the <code class="docutils literal"><span class="pre">output_ports</span></code> parameter which
is set to a <code class="docutils literal"><span class="pre">list</span></code> of port identifiers. The port identifiers are
arbitrary but must be hashable. Port identifiers allow the ability
to submit tuples &#8220;logically&#8217; rather than through a port index. Typically
a port identifier will be a <cite>str</cite> or an <cite>enum</cite>. The size of the list
defines the number of output ports with the first identifier in the list
coresponding to the first output port of the operator at index zero.
If the list is empty or not set then the operator has no output ports.</p>
<p>Tuples are submitted to an output port using <a class="reference internal" href="#streamsx.spl.spl.PrimitiveOperator.submit" title="streamsx.spl.spl.PrimitiveOperator.submit"><code class="xref py py-meth docutils literal"><span class="pre">submit()</span></code></a>.</p>
<p>When an operator has output ports it must be a sub-class of
<a class="reference internal" href="#streamsx.spl.spl.PrimitiveOperator" title="streamsx.spl.spl.PrimitiveOperator"><code class="xref py py-class docutils literal"><span class="pre">PrimitiveOperator</span></code></a> which provides the
<a class="reference internal" href="#streamsx.spl.spl.PrimitiveOperator.submit" title="streamsx.spl.spl.PrimitiveOperator.submit"><code class="xref py py-meth docutils literal"><span class="pre">submit()</span></code></a> method and the ports
ready notification mechanism <a class="reference internal" href="#streamsx.spl.spl.PrimitiveOperator.all_ports_ready" title="streamsx.spl.spl.PrimitiveOperator.all_ports_ready"><code class="xref py py-meth docutils literal"><span class="pre">all_ports_ready()</span></code></a>.</p>
<p>Example definition of an operator with a single input port and two output ports:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">primitive_operator</span><span class="p">(</span><span class="n">output_ports</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;MATCH&#39;</span><span class="p">,</span> <span class="s1">&#39;NEAR_MATCH&#39;</span><span class="p">])</span>
<span class="k">class</span> <span class="nc">SelectCustomers</span><span class="p">(</span><span class="n">spl</span><span class="o">.</span><span class="n">PrimitiveOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Score customers using a model.</span>
<span class="sd">    Customers that are a good match are submitted to port 0 (&#39;MATCH&#39;)</span>
<span class="sd">    while customers that are a near match are submitted to port 1 (&#39;NEAR_MATCH&#39;).</span>

<span class="sd">    Customers that are not a good or near match are not submitted to any port.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">near_match</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">match</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">near_match</span> <span class="o">=</span> <span class="n">near_match</span>

    <span class="nd">@spl</span><span class="o">.</span><span class="n">input_port</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">customers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">tuple_</span><span class="p">):</span>
         <span class="n">customer_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">tuple_</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">customer_score</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">:</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="s1">&#39;MATCH&#39;</span><span class="p">,</span> <span class="n">tuple_</span><span class="p">)</span>
         <span class="k">elif</span> <span class="n">customer_score</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">near_match</span><span class="p">:</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="s1">&#39;NEAR_MATCH&#39;</span><span class="p">,</span> <span class="n">tuple_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">customer</span><span class="p">):</span>
        <span class="c1"># Actual model scoring omitted</span>
        <span class="n">score</span> <span class="o">=</span> <span class="o">...</span>
        <span class="k">return</span> <span class="n">score</span>
</pre></div>
</div>
<p>Example SPL invocation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">Customers</span><span class="o">&gt;</span> <span class="n">MakeOffer</span><span class="p">;</span> <span class="n">stream</span><span class="o">&lt;</span><span class="n">Customers</span><span class="o">&gt;</span> <span class="n">ImproveOffer</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">SelectCustomers</span><span class="p">(</span><span class="n">Customers</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">param</span>
        <span class="n">match</span><span class="p">:</span> <span class="mf">0.9</span><span class="p">;</span>
        <span class="n">near_match</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>output_ports</strong> (<em>list</em>) &#8211; List of identifiers for output ports.</li>
<li><strong>docpy</strong> &#8211; Copy Python docstrings into SPL operator model for SPLDOC.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="streamsx.spl.spl.sink">
<code class="descclassname">streamsx.spl.spl.</code><code class="descname">sink</code><span class="sig-paren">(</span><em>wrapped</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.spl.spl.sink" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an SPL operator with a single input port.</p>
<p>A SPL operator with a single input port and no output ports.
For each tuple on the input port the decorated function
is called passing the contents of the tuple.</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 1.8: </span>Recommended to use <a class="reference internal" href="#streamsx.spl.spl.for_each" title="streamsx.spl.spl.for_each"><code class="xref py py-class docutils literal"><span class="pre">&#64;spl.for_each</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="streamsx.spl.spl.source">
<em class="property">class </em><code class="descclassname">streamsx.spl.spl.</code><code class="descname">source</code><span class="sig-paren">(</span><em>docpy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.spl.spl.source" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Create a source SPL operator from an iterable.
The resulting SPL operator has a single output port.</p>
<p>When decorating a class the class must be iterable
having an <code class="docutils literal"><span class="pre">__iter__</span></code> function. When the SPL operator
is invoked an instance of the class is created
and an iteration is created using <code class="docutils literal"><span class="pre">iter(instance)</span></code>.</p>
<p>When decoratiing a function the function must have no
parameters and must return an iterable or iteration.
When the SPL operator is invoked the function is called
and an iteration is created using <code class="docutils literal"><span class="pre">iter(value)</span></code>
where <code class="docutils literal"><span class="pre">value</span></code> is the return of the function.</p>
<p>For each value in the iteration SPL zero or more tuples
are submitted to the output port, derived from the value,
see <a class="reference internal" href="#submit-from-python"><span class="std std-ref">Submission of SPL tuples from Python</span></a>.</p>
<p>If the iteration completes then no more tuples
are submitted and a final punctuation mark
is submitted to the output port.</p>
<p>Example definition:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@spl</span><span class="o">.</span><span class="n">source</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">Range</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">))</span>
</pre></div>
</div>
<p>Example SPL invocation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">stream</span><span class="o">&lt;</span><span class="n">int32</span> <span class="n">seq</span><span class="o">&gt;</span> <span class="n">R</span> <span class="o">=</span> <span class="n">Range</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">param</span>
        <span class="n">stop</span><span class="p">:</span> <span class="mi">100</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>docpy</strong> &#8211; Copy Python docstrings into SPL operator model for SPLDOC.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015,2017 IBM Corp..

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.8.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>