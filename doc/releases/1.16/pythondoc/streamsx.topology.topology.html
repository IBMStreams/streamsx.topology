

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>streamsx.topology.topology &mdash; streamsx 1.16.0a documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="streamsx.topology.context" href="streamsx.topology.context.html" />
    <link rel="prev" title="streamsx.topology" href="streamsx.topology.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> streamsx
          

          
          </a>

          
            
            
              <div class="version">
                1.16
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="streamsx.topology.html">streamsx.topology</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">streamsx.topology.topology</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#topology">Topology</a></li>
<li class="toctree-l2"><a class="reference internal" href="#stream">Stream</a></li>
<li class="toctree-l2"><a class="reference internal" href="#stream-processing">Stream processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#callables">Callables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stateful-operations">Stateful operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initialization-and-shutdown">Initialization and shutdown</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tuple-semantics">Tuple semantics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#application-log-and-trace">Application log and trace</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spl-operators">SPL operators</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-contents">Module contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="streamsx.topology.context.html">streamsx.topology.context</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamsx.topology.schema.html">streamsx.topology.schema</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamsx.topology.state.html">streamsx.topology.state</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamsx.topology.composite.html">streamsx.topology.composite</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamsx.topology.tester.html">streamsx.topology.tester</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamsx.topology.tester_runtime.html">streamsx.topology.tester_runtime</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamsx.ec.html">streamsx.ec</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamsx.spl.op.html">streamsx.spl.op</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamsx.spl.types.html">streamsx.spl.types</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamsx.spl.toolkit.html">streamsx.spl.toolkit</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="streamsx.spl.spl.html">streamsx.spl.spl</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="streamsx.build.html">streamsx.build</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamsx.rest.html">streamsx.rest</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamsx.rest_primitives.html">streamsx.rest_primitives</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="scripts/extract.html">spl-python-extract</a></li>
<li class="toctree-l1"><a class="reference internal" href="scripts/info.html">streamsx-info</a></li>
<li class="toctree-l1"><a class="reference internal" href="scripts/runner.html">streamsx-runner</a></li>
<li class="toctree-l1"><a class="reference internal" href="scripts/sc.html">streamsx-sc</a></li>
<li class="toctree-l1"><a class="reference internal" href="scripts/service.html">streamsx-service</a></li>
<li class="toctree-l1"><a class="reference internal" href="scripts/streamtool.html">streamsx-streamtool</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="service.html">IBM Streaming Analytics service</a></li>
<li class="toctree-l1"><a class="reference internal" href="pysetup.html">IBM Streams Python setup</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="restrictions.html">Restrictions and known bugs</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">streamsx</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>streamsx.topology.topology</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/streamsx.topology.topology.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-streamsx.topology.topology">
<span id="streamsx-topology-topology"></span><h1>streamsx.topology.topology<a class="headerlink" href="#module-streamsx.topology.topology" title="Permalink to this headline">¶</a></h1>
<p>Streaming application definition.</p>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>IBM Streams is an advanced analytic platform that allows user-developed
applications to quickly ingest, analyze and correlate information as it
arrives from thousands of real-time sources.
Streams can handle very high data throughput rates, millions of events
or messages per second.</p>
<p>With this API Python developers can build streaming applications
that can be executed using IBM Streams, including the processing
being distributed across multiple computing resources
(hosts or machines) for scalability.</p>
</div>
<div class="section" id="topology">
<h2>Topology<a class="headerlink" href="#topology" title="Permalink to this headline">¶</a></h2>
<p>A <a class="reference internal" href="#streamsx.topology.topology.Topology" title="streamsx.topology.topology.Topology"><code class="xref py py-class docutils literal notranslate"><span class="pre">Topology</span></code></a> declares a graph of <em>streams</em> and <em>operations</em> against
tuples (data items) on those streams.</p>
<p>After being declared, a Topology is submitted to be compiled into
a Streams application bundle (sab file) and then executed.
The sab file is a self contained bundle that can be executed
in a distributed Streams instance either using the Streaming
Analytics service on IBM Cloud or an on-premise
IBM Streams installation.</p>
<p>The compilation step invokes the Streams compiler to produce a bundle.
This effectively, from a Python point of view, produces a runnable
version of the Python topology that includes application
specific Python C extensions to optimize performance.</p>
<p>The bundle also includes any required Python packages or modules
that were used in the declaration of the application, excluding
ones that are in a directory path containing <code class="docutils literal notranslate"><span class="pre">site-packages</span></code>.</p>
<p>The Python standard package tool <code class="docutils literal notranslate"><span class="pre">pip</span></code> uses a directory structure
including <code class="docutils literal notranslate"><span class="pre">site-packages</span></code> when installing packages. Packages installed
with <code class="docutils literal notranslate"><span class="pre">pip</span></code> can be included in the bundle with
<a class="reference internal" href="#streamsx.topology.topology.Topology.add_pip_package" title="streamsx.topology.topology.Topology.add_pip_package"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_pip_package()</span></code></a> when using a build service.
This avoids the requirement to have packages be preinstalled in cloud environments.</p>
<p>Local Python packages and modules containing callables used in transformations
such as <a class="reference internal" href="#streamsx.topology.topology.Stream.map" title="streamsx.topology.topology.Stream.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">map()</span></code></a> are copied into the bundle from their
local location.  The addition of local packages to the bundle can be controlled
with <a class="reference internal" href="#streamsx.topology.topology.Topology.include_packages" title="streamsx.topology.topology.Topology.include_packages"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Topology.include_packages</span></code></a> and
<a class="reference internal" href="#streamsx.topology.topology.Topology.exclude_packages" title="streamsx.topology.topology.Topology.exclude_packages"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Topology.exclude_packages</span></code></a>.</p>
<p>The Streams runtime distributes the application’s operations
across the resources available in the instance.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><cite>Topology</cite> represents a declaration of a streaming application that
will be executed by a Streams instance as a <cite>job</cite>, either using the Streaming Analytics
service on IBM Cloud or an on-premises distributed instance.
<cite>Topology</cite> does not represent a running application, so an instance of <cite>Stream</cite> class does not contain
the tuples, it is only a declaration of a stream.</p>
</div>
</div>
<div class="section" id="stream">
<span id="stream-desc"></span><h2>Stream<a class="headerlink" href="#stream" title="Permalink to this headline">¶</a></h2>
<p>A <a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> can be an infinite sequence of tuples, such as a stream for a traffic flow sensor.
Alternatively, a stream can be finite, such as a stream that is created from the contents of a file.
When a streams processing application contains infinite streams, the application runs continuously without ending.</p>
<p>A stream has a schema that defines the type of each tuple on the stream.
The schema for a stream is either:</p>
<ul class="simple">
<li><p><a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.Python" title="streamsx.topology.schema.CommonSchema.Python"><code class="xref py py-const docutils literal notranslate"><span class="pre">Python</span></code></a> - A tuple may be any Python object. This is the default when the schema is not explictly or implicitly set.</p></li>
<li><p><a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.String" title="streamsx.topology.schema.CommonSchema.String"><code class="xref py py-const docutils literal notranslate"><span class="pre">String</span></code></a> - Each tuple is a Unicode string.</p></li>
<li><p><a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.Binary" title="streamsx.topology.schema.CommonSchema.Binary"><code class="xref py py-const docutils literal notranslate"><span class="pre">Binary</span></code></a> - Each tuple is a blob.</p></li>
<li><p><a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.Json" title="streamsx.topology.schema.CommonSchema.Json"><code class="xref py py-const docutils literal notranslate"><span class="pre">Json</span></code></a> - Each tuple is a Python dict that can be expressed as a JSON object.</p></li>
<li><p>Structured - A stream that has a structured schema of a ordered list of attributes, with each attribute having a fixed type (e.g. float64 or int32) and a name. The schema of a structured stream is defined using typed named tuple or <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.StreamSchema" title="streamsx.topology.schema.StreamSchema"><code class="xref py py-const docutils literal notranslate"><span class="pre">StreamSchema</span></code></a>.</p></li>
</ul>
<p>A stream’s schema is implictly dervied from type hints declared for the callable
of the transform that produces it. For example <cite>readings</cite> defined as follows would have a structured schema matching <code class="docutils literal notranslate"><span class="pre">SensorReading</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SensorReading</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">sensor_id</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">ts</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">reading</span><span class="p">:</span> <span class="nb">float</span>

<span class="k">def</span> <span class="nf">reading_from_json</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SensorReading</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">SensorReading</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="s1">&#39;reading&#39;</span><span class="p">])</span>

<span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
<span class="n">json_readings</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">HttpReadings</span><span class="p">())</span><span class="o">.</span><span class="n">as_json</span><span class="p">()</span>
<span class="n">readings</span> <span class="o">=</span> <span class="n">json_readings</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">reading_from_json</span><span class="p">)</span>
</pre></div>
</div>
<p>Deriving schemas from type hints can be disabled by setting the topology’s
<code class="docutils literal notranslate"><span class="pre">type_checking</span></code> attribute to false, for example this would change <cite>readings</cite>
in the previous example to have generic Python object schema <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.Python" title="streamsx.topology.schema.CommonSchema.Python"><code class="xref py py-const docutils literal notranslate"><span class="pre">Python</span></code></a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
<span class="n">topo</span><span class="o">.</span><span class="n">type_checking</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
<div class="section" id="stream-processing">
<h2>Stream processing<a class="headerlink" href="#stream-processing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="callables">
<h3>Callables<a class="headerlink" href="#callables" title="Permalink to this headline">¶</a></h3>
<p>A stream is processed to produce zero or more transformed streams,
such as filtering a stream to drop unwanted tuples, producing a stream
that only contains the required tuples.</p>
<p>Streaming processing is per tuple based, as each tuple is submitted to a stream consuming operators
have their processing logic invoked for that tuple.</p>
<p>A functional operator is declared by methods on <a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> such as <a class="reference internal" href="#streamsx.topology.topology.Stream.map" title="streamsx.topology.topology.Stream.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">map()</span></code></a> which
maps the tuples on its input stream to tuples on its output stream. <cite>Stream</cite> uses a functional model
where each stream processing operator is defined in terms a Python callable that is invoked passing
input tuples and whose return defines what output tuples are submitted for downstream processing.</p>
<p>The Python callable used for functional processing in this API may be:</p>
<ul class="simple">
<li><p>A Python lambda function.</p></li>
<li><p>A Python function.</p></li>
<li><p>An instance of a Python callable class.</p></li>
</ul>
<p>For example a stream <code class="docutils literal notranslate"><span class="pre">words</span></code> containing only string objects can be
processed by a <a class="reference internal" href="#streamsx.topology.topology.Stream.filter" title="streamsx.topology.topology.Stream.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> using a lambda function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Filter the stream so it only contains words starting with py</span>
<span class="n">pywords</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">word</span> <span class="p">:</span> <span class="n">word</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;py&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>When a callable has type hints they are used to:</p>
<blockquote>
<div><ul class="simple">
<li><p>define the schema of the resulting transformation, see  <a class="reference internal" href="#stream-desc"><span class="std std-ref">Stream</span></a>.</p></li>
<li><p>type checking the correctness of the transformation at topology declaration time.</p></li>
</ul>
</div></blockquote>
<p>For example if the callable defining the source had type hints that indicated
it was an iterator of <code class="docutils literal notranslate"><span class="pre">str</span></code> objects then the schema of the resultant stream
would be <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.String" title="streamsx.topology.schema.CommonSchema.String"><code class="xref py py-const docutils literal notranslate"><span class="pre">String</span></code></a>. If this
source stream then underwent a <a class="reference internal" href="#streamsx.topology.topology.Stream.map" title="streamsx.topology.topology.Stream.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Stream.map()</span></code></a> transform with a callable
that had a type hint for its argument, a check is made to ensure
that the type of the argument is compatible with <code class="docutils literal notranslate"><span class="pre">str</span></code>.</p>
<p>Type hints are maintained through transforms regardless of resultant schema.
For example a transform that has a return type hint of <code class="docutils literal notranslate"><span class="pre">int</span></code> defines
the schema as <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.Python" title="streamsx.topology.schema.CommonSchema.Python"><code class="xref py py-const docutils literal notranslate"><span class="pre">Python</span></code></a>,
but the type hint is retained even though the schema is generic. Thus an
error is raised at topology declaration time if a downstream transformation
uses a callable with a type hint that is incompatible with being passed an <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
<p>How type hints are used is specific to each transformation, such as
<a class="reference internal" href="#streamsx.topology.topology.Topology.source" title="streamsx.topology.topology.Topology.source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">source()</span></code></a>, <a class="reference internal" href="#streamsx.topology.topology.Stream.map" title="streamsx.topology.topology.Stream.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">map()</span></code></a>, <a class="reference internal" href="#streamsx.topology.topology.Stream.filter" title="streamsx.topology.topology.Stream.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> etc.</p>
<p>Type checking can be disabled by setting the topology’s <code class="docutils literal notranslate"><span class="pre">type_checking</span></code> attribute to false.</p>
<p>When a callable is a lambda or defined inline (defined in the main Python script,
a notebook or an interactive session) then a serialized copy of its definition becomes part of the
topology. The supported types of captured globals for these callables is limited to
avoid increasing the size of the application and serialization failures due non-serializable
objects directly or indirectly referenced from captured globals. The supported types of captured globals
are constants (<code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">str</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="docutils literal notranslate"><span class="pre">complex</span></code>), modules, module attributes (e.g. classes, functions and variables
defined in a module), inline classes and functions. If a lambda or inline callable causes an exception due to unsupported global
capture then moving it to its own module is a solution.</p>
<p>Due to <a class="reference external" href="https://bugs.python.org/issue36697">Python bug 36697</a> a lambda or inline callable can
incorrect capture a global variable. For example an inline class using a attribute of <code class="docutils literal notranslate"><span class="pre">self.model</span></code>
will incorrectly capture the global <code class="docutils literal notranslate"><span class="pre">model</span></code> even if the global variable <code class="docutils literal notranslate"><span class="pre">model</span></code> is never used within the class.
To workaround this bug use attribute or variable names that do not shadow global variables
(e.g. <code class="docutils literal notranslate"><span class="pre">self._model</span></code>).</p>
<p>Due to <a class="reference external" href="https://github.com/IBMStreams/streamsx.topology/issues/2336">issue 2336</a> an inline class using <code class="docutils literal notranslate"><span class="pre">super()</span></code> will cause an <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> at runtime. Workaround is to call the super class’s method directly, for example replace this code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
</pre></div>
</div>
<p>with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">X</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>or move the class to a module.</p>
</div>
<div class="section" id="stateful-operations">
<h3>Stateful operations<a class="headerlink" href="#stateful-operations" title="Permalink to this headline">¶</a></h3>
<p>Use of a class instance allows the operation to be stateful by maintaining state in instance
attributes across invocations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For support with consistent region or checkpointing instances should ensure that the object’s state can be pickled. See <a class="reference external" href="https://docs.python.org/3.5/library/pickle.html#handling-stateful-objects">https://docs.python.org/3.5/library/pickle.html#handling-stateful-objects</a></p>
</div>
</div>
<div class="section" id="initialization-and-shutdown">
<h3>Initialization and shutdown<a class="headerlink" href="#initialization-and-shutdown" title="Permalink to this headline">¶</a></h3>
<p>Execution of a class instance effectively run in a context manager so that an instance’s <code class="docutils literal notranslate"><span class="pre">__enter__</span></code>
method is called when the processing element containing the instance  is initialized
and its <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> method called when the processing element is stopped. To take advantage of this
the class must define both <code class="docutils literal notranslate"><span class="pre">__enter__</span></code> and <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> methods.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since an instance of a class is passed to methods such as
<a class="reference internal" href="#streamsx.topology.topology.Stream.map" title="streamsx.topology.topology.Stream.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">map()</span></code></a> <code class="docutils literal notranslate"><span class="pre">__init__</span></code> is only called when the topology is <cite>declared</cite>, not at runtime.
Initialization at runtime, such as opening connections, occurs through the <code class="docutils literal notranslate"><span class="pre">__enter__</span></code> method.</p>
</div>
<p>Example of using <code class="docutils literal notranslate"><span class="pre">__enter__</span></code> to create custom metrics:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">streamsx.ec</span> <span class="k">as</span> <span class="nn">ec</span>

<span class="k">class</span> <span class="nc">Sentiment</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positive_metric</span> <span class="o">=</span> <span class="n">ec</span><span class="o">.</span><span class="n">CustomMetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;positiveSentiment&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">negative_metric</span> <span class="o">=</span> <span class="n">ec</span><span class="o">.</span><span class="n">CustomMetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;negativeSentiment&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>When an instance defines a valid <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> method then it will be called with an exception when:</p>
<blockquote>
<div><ul class="simple">
<li><p>the instance raises an exception during processing of a tuple</p></li>
<li><p>a data conversion exception is raised converting a value to an structured schema tuple or attribute</p></li>
</ul>
</div></blockquote>
<p>If <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> returns a true value then the exception is suppressed and processing continues, otherwise the enclosing processing element will be terminated.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> method requires four parameters, whereas the last three parameters are set when exception is raised only:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">exc_type</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exc_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="o">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="tuple-semantics">
<h3>Tuple semantics<a class="headerlink" href="#tuple-semantics" title="Permalink to this headline">¶</a></h3>
<p>Python objects on a stream may be passed by reference between callables (e.g. the value returned by a map callable may be passed by reference to a following filter callable). This can only occur when the functions are executing in the same PE (process). If an object is not passed by reference a deep-copy is passed. Streams that cross PE (process) boundaries  are always passed by deep-copy.</p>
<p>Thus if a stream is consumed by two map and one filter callables in the same PE they may receive the same object reference that was sent by the upstream callable. If one (or more) callable modifies the passed in reference those changes may be seen by the upstream callable or the other callables. The order of execution of the downstream callables is not defined. One can prevent such potential non-deterministic behavior by one or more of these techniques:</p>
<ul class="simple">
<li><p>Passing immutable objects</p></li>
<li><p>Not retaining a reference to an object that will be submitted on a stream</p></li>
<li><p>Not modifying input tuples in a callable</p></li>
<li><p>Using copy/deepcopy when returning a value that will be submitted to a stream.</p></li>
</ul>
<p>Applications cannot rely on pass-by reference,  it is a performance optimization that can be made in some situations when stream connections are within a PE.</p>
</div>
<div class="section" id="application-log-and-trace">
<h3>Application log and trace<a class="headerlink" href="#application-log-and-trace" title="Permalink to this headline">¶</a></h3>
<p>IBM Streams provides application trace and log services which are
accesible through standard Python loggers from the <cite>logging</cite> module.</p>
<p>See <a class="reference internal" href="streamsx.ec.html#streams-app-log-trc"><span class="std std-ref">Application log and trace</span></a>.</p>
</div>
<div class="section" id="spl-operators">
<h3>SPL operators<a class="headerlink" href="#spl-operators" title="Permalink to this headline">¶</a></h3>
<p>In addition an application declared by <cite>Topology</cite> can include stream processing defined by SPL primitive or
composite operators. This allows reuse of adapters and analytics provided by IBM Streams,
open source and third-party SPL toolkits.</p>
<p>See <a class="reference internal" href="streamsx.spl.op.html#module-streamsx.spl.op" title="streamsx.spl.op"><code class="xref py py-mod docutils literal notranslate"><span class="pre">streamsx.spl.op</span></code></a></p>
</div>
</div>
<div class="section" id="module-contents">
<h2>Module contents<a class="headerlink" href="#module-contents" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id1">
<h2>Module contents<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p class="rubric">Classes</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#streamsx.topology.topology.PendingStream" title="streamsx.topology.topology.PendingStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PendingStream</span></code></a></p></td>
<td><p>Pending stream connection.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#streamsx.topology.topology.Routing" title="streamsx.topology.topology.Routing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Routing</span></code></a></p></td>
<td><p>Defines how tuples are routed to channels in a parallel region.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#streamsx.topology.topology.Sink" title="streamsx.topology.topology.Sink"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sink</span></code></a></p></td>
<td><p>Termination of a <cite>Stream</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Stream</span></code></a></p></td>
<td><p>The Stream class is the primary abstraction within a streaming application.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#streamsx.topology.topology.SubscribeConnection" title="streamsx.topology.topology.SubscribeConnection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SubscribeConnection</span></code></a></p></td>
<td><p>Connection mode between a subscriber and matching publishers.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#streamsx.topology.topology.Topology" title="streamsx.topology.topology.Topology"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Topology</span></code></a></p></td>
<td><p>The Topology class is used to define data sources, and is passed as a parameter when submitting an application.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#streamsx.topology.topology.View" title="streamsx.topology.topology.View"><code class="xref py py-obj docutils literal notranslate"><span class="pre">View</span></code></a></p></td>
<td><p>The View class provides access to a continuously updated sampling of data items on a <a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> after submission.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#streamsx.topology.topology.Window" title="streamsx.topology.topology.Window"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Window</span></code></a></p></td>
<td><p>Declaration of a window of tuples on a <cite>Stream</cite>.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="streamsx.topology.topology.Routing">
<em class="property">class </em><code class="sig-prename descclassname">streamsx.topology.topology.</code><code class="sig-name descname">Routing</code><a class="headerlink" href="#streamsx.topology.topology.Routing" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>Defines how tuples are routed to channels in a
parallel region.</p>
<p>A parallel region is started by <a class="reference internal" href="#streamsx.topology.topology.Stream.parallel" title="streamsx.topology.topology.Stream.parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parallel()</span></code></a>
and ended with <a class="reference internal" href="#streamsx.topology.topology.Stream.end_parallel" title="streamsx.topology.topology.Stream.end_parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">end_parallel()</span></code></a> or <a class="reference internal" href="#streamsx.topology.topology.Stream.for_each" title="streamsx.topology.topology.Stream.for_each"><code class="xref py py-meth docutils literal notranslate"><span class="pre">for_each()</span></code></a>.</p>
<dl class="attribute">
<dt id="streamsx.topology.topology.Routing.BROADCAST">
<code class="sig-name descname">BROADCAST</code><em class="property"> = 0</em><a class="headerlink" href="#streamsx.topology.topology.Routing.BROADCAST" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuples are routed to every channel in the parallel region.</p>
</dd></dl>

<dl class="attribute">
<dt id="streamsx.topology.topology.Routing.HASH_PARTITIONED">
<code class="sig-name descname">HASH_PARTITIONED</code><em class="property"> = 3</em><a class="headerlink" href="#streamsx.topology.topology.Routing.HASH_PARTITIONED" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuples are routed based upon a hash value so that tuples with the same hash
and thus same value are always routed to the same channel. When a hash function is
specified it is passed the tuple and the return value is the hash. When no hash
function is specified then <cite>hash(tuple)</cite> is used.</p>
<p>Each tuple is only sent to a single channel.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>A consistent hash function is required to guarantee that a tuple
with the same value is always routed to the same channel. <cite>hash()</cite> is not
consistent in that for types str, bytes and datetime objects are “salted”
with an unpredictable random value (Python 3.5). Thus if the processing element is
restarted channel routing for a hash based upon a str, bytes or datetime will change.
In addition code executing in the channels can see a different
hash value to other channels and the execution that routed the tuple due to
being in different processing elements.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="streamsx.topology.topology.Routing.KEY_PARTITIONED">
<code class="sig-name descname">KEY_PARTITIONED</code><em class="property"> = 2</em><a class="headerlink" href="#streamsx.topology.topology.Routing.KEY_PARTITIONED" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuples are routed based upon specified partitioning keys.
The splitter routes tuples that have the same values for these keys (list of attributes) to the same parallel channel.
The keys must exist in the tuple type that is specified for the input stream.
Requires a structured stream <code class="xref py py-class docutils literal notranslate"><span class="pre">StreamSchema</span></code> or named tuple as input stream.</p>
<p>Each tuple is only sent to a single channel.</p>
</dd></dl>

<dl class="attribute">
<dt id="streamsx.topology.topology.Routing.ROUND_ROBIN">
<code class="sig-name descname">ROUND_ROBIN</code><em class="property"> = 1</em><a class="headerlink" href="#streamsx.topology.topology.Routing.ROUND_ROBIN" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuples are routed to maintain an even distribution of tuples to the channels.</p>
<p>Each tuple is only sent to a single channel.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="streamsx.topology.topology.SubscribeConnection">
<em class="property">class </em><code class="sig-prename descclassname">streamsx.topology.topology.</code><code class="sig-name descname">SubscribeConnection</code><a class="headerlink" href="#streamsx.topology.topology.SubscribeConnection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>Connection mode between a subscriber and matching publishers.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#streamsx.topology.topology.Topology.subscribe" title="streamsx.topology.topology.Topology.subscribe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subscribe()</span></code></a></p>
</div>
<dl class="attribute">
<dt id="streamsx.topology.topology.SubscribeConnection.Buffered">
<code class="sig-name descname">Buffered</code><em class="property"> = 1</em><a class="headerlink" href="#streamsx.topology.topology.SubscribeConnection.Buffered" title="Permalink to this definition">¶</a></dt>
<dd><p>Buffered connection between a subscriber and and matching publishers.</p>
<p>With a buffered connection tuples from publishers are placed in
a single queue owned by the subscriber. This allows a slower
subscriber to handle brief spikes in tuples from publishers.</p>
<p>A subscriber can fully isolate itself from matching publishers
by adding a <code class="xref py py-class docutils literal notranslate"><span class="pre">CongestionPolicy</span></code> that drops tuples
when the queue is full. In this case when the subscriber is
not able to keep up with the tuple rate from all matching subscribers
it will have a minimal effect on matching publishers.</p>
</dd></dl>

<dl class="attribute">
<dt id="streamsx.topology.topology.SubscribeConnection.Direct">
<code class="sig-name descname">Direct</code><em class="property"> = 0</em><a class="headerlink" href="#streamsx.topology.topology.SubscribeConnection.Direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct connection between a subscriber and and matching publishers.</p>
<p>When connected directly a slow subscriber will cause back-pressure
against the publishers, forcing them to slow tuple processing to
the slowest publisher.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="streamsx.topology.topology.Topology">
<em class="property">class </em><code class="sig-prename descclassname">streamsx.topology.topology.</code><code class="sig-name descname">Topology</code><span class="sig-paren">(</span><em class="sig-param">name=None</em>, <em class="sig-param">namespace=None</em>, <em class="sig-param">files=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Topology" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The Topology class is used to define data sources, and is passed as a parameter when submitting an application. Topology keeps track of all sources, sinks, and transformations within your application.</p>
<p>Submission of a Topology results in a Streams application that has
the name <cite>namespace::name</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Name of the topology. Defaults to a name dervied from the calling evironment if it can be determined, otherwise a random name.</p></li>
<li><p><strong>namespace</strong> (<em>str</em>) – Namespace of the topology. Defaults to a name dervied from the calling evironment if it can be determined, otherwise a random name.</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="streamsx.topology.topology.Topology.include_packages">
<code class="sig-name descname">include_packages</code><a class="headerlink" href="#streamsx.topology.topology.Topology.include_packages" title="Permalink to this definition">¶</a></dt>
<dd><p>Python package names to be included in the built application. Any package in this list is copied into the bundle and made available at runtime to the Python callables used in the application. By default a <code class="docutils literal notranslate"><span class="pre">Topology</span></code> will automatically discover which packages and modules are required to be copied, this field may be used to add additional packages that were not automatically discovered. See also <a class="reference internal" href="#streamsx.topology.topology.Topology.add_pip_package" title="streamsx.topology.topology.Topology.add_pip_package"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_pip_package()</span></code></a>. Package names in <cite>include_packages</cite> take precedence over package names in <cite>exclude_packages</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>set[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="streamsx.topology.topology.Topology.exclude_packages">
<code class="sig-name descname">exclude_packages</code><a class="headerlink" href="#streamsx.topology.topology.Topology.exclude_packages" title="Permalink to this definition">¶</a></dt>
<dd><p>Python top-level package names to be excluded from the built application. Excluding a top-level packages excludes all sub-modules at any level in the package, e.g. <cite>sound</cite> excludes <cite>sound.effects.echo</cite>. Only the top-level package can be defined, e.g. <cite>sound</cite> rather than <cite>sound.filters</cite>. Behavior when adding a module within a package is undefined. When compiling the application using Anaconda this set is pre-loaded with Python packages from the Anaconda pre-loaded set.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>set[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="streamsx.topology.topology.Topology.type_checking">
<code class="sig-name descname">type_checking</code><a class="headerlink" href="#streamsx.topology.topology.Topology.type_checking" title="Permalink to this definition">¶</a></dt>
<dd><p>Set to false to disable type checking, defaults to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="streamsx.topology.topology.Topology.name_to_runtime_id">
<code class="sig-name descname">name_to_runtime_id</code><a class="headerlink" href="#streamsx.topology.topology.Topology.name_to_runtime_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Optional callable that returns a runtime identifier for a name. Used to override the default mapping of a name into a runtime identifer. It will be called with <cite>name</cite> and returns a valid SPL identifier or <code class="docutils literal notranslate"><span class="pre">None</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned then the default mapping for <cite>name</cite> is used. Defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code> indicating the default mapping is used. See <a class="reference internal" href="#streamsx.topology.topology.Stream.runtime_id" title="streamsx.topology.topology.Stream.runtime_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Stream.runtime_id</span></code></a>.</p>
</dd></dl>

<p>All declared streams in a <cite>Topology</cite> are available through their name
using <code class="docutils literal notranslate"><span class="pre">topology[name]</span></code>. The stream’s name is defined by <a class="reference internal" href="#streamsx.topology.topology.Stream.name" title="streamsx.topology.topology.Stream.name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Stream.name()</span></code></a> and will differ from the name parameter passed when creating the stream if the application uses duplicate names.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.11: </span>Declared streams available through <code class="docutils literal notranslate"><span class="pre">topology[name]</span></code>.</p>
</div>
<dl class="method">
<dt id="streamsx.topology.topology.Topology.add_file_dependency">
<code class="sig-name descname">add_file_dependency</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">location</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Topology.add_file_dependency" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a file or directory dependency into an Streams application bundle.</p>
<p>Ensures that the file or directory at <cite>path</cite> on the local system
will be available at runtime.</p>
<p>The file will be copied and made available relative to the
application directory. Location determines where the file
is relative to the application directory. Two values for
location are supported <cite>etc</cite> and <cite>opt</cite>.
The runtime path relative to application directory is returned.</p>
<p>The copy is made during the submit call thus the contents of
the file or directory must remain availble until submit returns.</p>
<p>For example calling
<code class="docutils literal notranslate"><span class="pre">add_file_dependency('/tmp/conf.properties',</span> <span class="pre">'etc')</span></code>
will result in contents of the local file <cite>conf.properties</cite>
being available at runtime at the path <cite>application directory</cite>/etc/conf.properties. This call returns <code class="docutils literal notranslate"><span class="pre">etc/conf.properties</span></code>.</p>
<p>Python callables can determine the application directory at
runtime with <a class="reference internal" href="streamsx.ec.html#streamsx.ec.get_application_directory" title="streamsx.ec.get_application_directory"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_application_directory()</span></code></a>.
For example the path above at runtime is
<code class="docutils literal notranslate"><span class="pre">os.path.join(streamsx.ec.get_application_directory(),</span> <span class="pre">'etc',</span> <span class="pre">'conf.properties')</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>str</em>) – Path of the file on the local system.</p></li>
<li><p><strong>location</strong> (<em>str</em>) – Location of the file in the bundle relative to the application directory.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Path relative to application directory that can be joined at runtime with <code class="docutils literal notranslate"><span class="pre">get_application_directory</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Topology.add_pip_package">
<code class="sig-name descname">add_pip_package</code><span class="sig-paren">(</span><em class="sig-param">requirement</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Topology.add_pip_package" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a Python package dependency for this topology.</p>
<p>If the package defined by the requirement specifier
is not pre-installed on the build system then the
package is installed using <cite>pip</cite> and becomes part
of the Streams application bundle (<cite>sab</cite> file).
The package is expected to be available from <cite>pypi.org</cite>.</p>
<p>If the package is already installed on the build system
then it is not added into the <cite>sab</cite> file.
The assumption is that the runtime hosts for a Streams
instance have the same Python packages installed as the
build machines. This is always true for IBM Cloud
Pak for Data and the Streaming Analytics service on IBM Cloud.</p>
<p>The project name extracted from the requirement
specifier is added to <a class="reference internal" href="#streamsx.topology.topology.Topology.exclude_packages" title="streamsx.topology.topology.Topology.exclude_packages"><code class="xref py py-attr docutils literal notranslate"><span class="pre">exclude_packages</span></code></a>
to avoid the package being added by the dependency
resolver. Thus the package should be added before
it is used in any stream transformation.</p>
<p>When an application is run with trace level <code class="docutils literal notranslate"><span class="pre">info</span></code>
the available Python packages on the running system
are listed to application trace. This includes
any packages added by this method.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
<span class="c1"># Add dependency on pint package</span>
<span class="c1"># and astral at version 0.8.1</span>
<span class="n">topo</span><span class="o">.</span><span class="n">add_pip_package</span><span class="p">(</span><span class="s1">&#39;pint&#39;</span><span class="p">)</span>
<span class="n">topo</span><span class="o">.</span><span class="n">add_pip_package</span><span class="p">(</span><span class="s1">&#39;astral==0.8.1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Example for packages not provided on pypi.org:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
<span class="c1"># Add dependency on package using whl file</span>
<span class="n">topo</span><span class="o">.</span><span class="n">add_pip_package</span><span class="p">(</span><span class="n">requirement</span><span class="o">=</span><span class="s1">&#39;https://github.com/myrepo/raw/mydir/mypkg-1.0-py3-none-any.whl&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;mypkg&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>requirement</strong> (<em>str</em>) – Package requirements specifier.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name added to <a class="reference internal" href="#streamsx.topology.topology.Topology.exclude_packages" title="streamsx.topology.topology.Topology.exclude_packages"><code class="xref py py-attr docutils literal notranslate"><span class="pre">exclude_packages</span></code></a>. Set this argument when adding URLs only.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Only supported when using the build service with
a Streams instance in Cloud Pak for Data
or Streaming Analytics service on IBM Cloud.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Installing packages through <cite>pip</cite> is preferred to
the automatic dependency checking performed on local
modules. This is because <cite>pip</cite> will perform a full
install of the package including any dependent packages
and additional files, such as shared libraries, that
might be missed by dependency discovery.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Topology.checkpoint_period">
<em class="property">property </em><code class="sig-name descname">checkpoint_period</code><a class="headerlink" href="#streamsx.topology.topology.Topology.checkpoint_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable checkpointing for the topology, and define the checkpoint
period.</p>
<p>When checkpointing is enabled, the state of all stateful operators
is saved periodically.  If the operator restarts, its state is
restored from the most recent checkpoint.</p>
<p>The checkpoint period is the frequency at which checkpoints will
be taken.  It can either be a <code class="xref py py-class docutils literal notranslate"><span class="pre">timedelta</span></code> value
or a floating point value in seconds.  It must be at 0.001
seconds or greater.</p>
<p>A stateful operator is an operator whose callable is an instance of a
Python callable class.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a topology that will checkpoint every thirty seconds</span>
<span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
<span class="n">topo</span><span class="o">.</span><span class="n">checkpoint_period</span> <span class="o">=</span> <span class="mf">30.0</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a topology that will checkpoint every two minutes</span>
<span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
<span class="n">topo</span><span class="o">.</span><span class="n">checkpoint_period</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.11.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Topology.create_submission_parameter">
<code class="sig-name descname">create_submission_parameter</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">default=None</em>, <em class="sig-param">type_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Topology.create_submission_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a submission parameter.</p>
<p>A submission parameter is a handle for a value that
is not defined until topology submission time.  Submission
parameters enable the creation of reusable topology bundles.</p>
<p>A submission parameter has a <cite>name</cite>. The name must be unique
within the topology.</p>
<p>The returned parameter is a <cite>callable</cite>.
Prior to submitting the topology, while constructing the topology,
invoking it returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>After the topology is submitted, invoking the parameter
within the executing topology returns the actual submission time value
(or the default value if it was not set at submission time).</p>
<p>Submission parameters may be used within functional logic. e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">threshold</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="n">create_submission_parameter</span><span class="p">(</span><span class="s1">&#39;threshold&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>

<span class="c1"># s is some stream of integers</span>
<span class="n">s</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span> <span class="p">:</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">())</span>
</pre></div>
</div>
<p>Submission parameters may be used to specify the degree of parallelism. e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stv_channels</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">create_submission_parameter</span><span class="p">(</span><span class="s1">&#39;num_channels&#39;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">67</span><span class="p">))</span><span class="o">.</span><span class="n">set_parallel</span><span class="p">(</span><span class="n">stv_channels</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span> <span class="p">:</span> <span class="n">v</span> <span class="o">%</span> <span class="n">stv_channels</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">end_parallel</span><span class="p">()</span>

<span class="n">jc</span> <span class="o">=</span> <span class="n">JobConfig</span><span class="p">()</span>
<span class="n">jc</span><span class="o">.</span><span class="n">submission_parameters</span><span class="p">[</span><span class="s1">&#39;num_channels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">jc</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cfg</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The parameter (value returned from this method) is only
supported within a lambda expression or a callable
that is not a function.</p>
</div>
<p>The default type of a submission parameter’s value is a <cite>str</cite>.
When a <cite>default</cite> is specified
the type of the value matches the type of the default.</p>
<p>If <cite>default</cite> is not set, then the type can be set with <cite>type_</cite>.</p>
<p>The types supported are <code class="docutils literal notranslate"><span class="pre">str</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code> and <code class="docutils literal notranslate"><span class="pre">bool</span></code>.</p>
<p>Topology submission behavior when a submission parameter
lacking a default value is created and a value is not provided at
submission time is defined by the underlying topology execution runtime.</p>
<blockquote>
<div><ul class="simple">
<li><p>Submission fails for contexts <code class="docutils literal notranslate"><span class="pre">DISTRIBUTED</span></code>, <code class="docutils literal notranslate"><span class="pre">STANDALONE</span></code>, and <code class="docutils literal notranslate"><span class="pre">STREAMING_ANALYTICS_SERVICE</span></code>.</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Name for submission parameter.</p></li>
<li><p><strong>default</strong> – Default parameter when submission parameter is not set.</p></li>
<li><p><strong>type_</strong> – Type of parameter value when default is not set. Supported values are <cite>str</cite>, <cite>int</cite>, <cite>float</cite> and <cite>bool</cite>.</p></li>
</ul>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="streamsx.ec.html#streamsx.ec.get_submission_time_value" title="streamsx.ec.get_submission_time_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">streamsx.ec.get_submission_time_value()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Topology.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#streamsx.topology.topology.Topology.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the topology.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Name of the topology.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Topology.namespace">
<em class="property">property </em><code class="sig-name descname">namespace</code><a class="headerlink" href="#streamsx.topology.topology.Topology.namespace" title="Permalink to this definition">¶</a></dt>
<dd><p>Namespace of the topology.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Namespace of the topology.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Topology.source">
<code class="sig-name descname">source</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Topology.source" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare a source stream that introduces tuples into the application.</p>
<p>Typically used to create a stream of tuple from an external source,
such as a sensor or reading from an external system.</p>
<p>Tuples are obtained from an iterator obtained from the passed iterable
or callable that returns an iterable.</p>
<p>Each tuple that is not None from the iterator is present on the returned stream.</p>
<p>Each tuple is a Python object and must be picklable to allow execution of the application
to be distributed across available resources in the Streams instance.</p>
<p>If the iterator’s <code class="docutils literal notranslate"><span class="pre">__iter__</span></code> or <code class="docutils literal notranslate"><span class="pre">__next__</span></code> block then shutdown,
checkpointing or consistent region processing may be delayed.
Having <code class="docutils literal notranslate"><span class="pre">__next__</span></code> return <code class="docutils literal notranslate"><span class="pre">None</span></code> (no available tuples) or tuples
to submit will allow such processing to proceed.</p>
<p>A shutdown <code class="docutils literal notranslate"><span class="pre">threading.Event</span></code> is available through
<a class="reference internal" href="streamsx.ec.html#streamsx.ec.shutdown" title="streamsx.ec.shutdown"><code class="xref py py-func docutils literal notranslate"><span class="pre">streamsx.ec.shutdown()</span></code></a> which becomes set when a shutdown
of the processing element has been requested. This event my be waited
on to perform a sleep that will terminate upon shutdown.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> (<em>callable</em>) – An iterable or a zero-argument callable that returns an iterable of tuples.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of the stream, defaults to a generated name.</p></li>
</ul>
</dd>
</dl>
<p>Exceptions raised by <code class="docutils literal notranslate"><span class="pre">func</span></code> or its iterator will cause
its processing element will terminate.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">func</span></code> is a callable object then it may suppress exceptions
by return a true value from its <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> method.</p>
<p>Suppressing an exception raised by <code class="docutils literal notranslate"><span class="pre">func.__iter__</span></code> causes the
source to be empty, no tuples are submitted to the stream.</p>
<p>Suppressing an exception raised by <code class="docutils literal notranslate"><span class="pre">__next__</span></code> on the iterator
results in no tuples being submitted for that call to <code class="docutils literal notranslate"><span class="pre">__next__</span></code>.
Processing continues with calls to <code class="docutils literal notranslate"><span class="pre">__next__</span></code> to fetch subsequent tuples.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A stream whose tuples are the result of the iterable obtained from <cite>func</cite>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream">Stream</a></p>
</dd>
</dl>
<p class="rubric">Type hints</p>
<p>Type hints on <cite>func</cite> define the schema of the returned stream,
defaulting to <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.Python" title="streamsx.topology.schema.CommonSchema.Python"><code class="xref py py-const docutils literal notranslate"><span class="pre">Python</span></code></a>
if no type hints are present.</p>
<p>For example <code class="docutils literal notranslate"><span class="pre">s_sensor</span></code> has a type hint that
defines it as an iterable of <code class="docutils literal notranslate"><span class="pre">SensorReading</span></code> instances (typed named tuples).
Thus <cite>readings</cite> has a structured schema matching <code class="docutils literal notranslate"><span class="pre">SensorReading</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">s_sensor</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">SensorReading</span><span class="p">]</span> <span class="p">:</span>
    <span class="o">...</span>

<span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
<span class="n">readings</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">s_sensor</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Simple examples</p>
<p>Finite constant source stream containing two tuples
<code class="docutils literal notranslate"><span class="pre">Hello</span></code> and <code class="docutils literal notranslate"><span class="pre">World</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
<span class="n">hw</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">source</span><span class="p">([</span><span class="s1">&#39;Hello&#39;</span><span class="p">,</span> <span class="s1">&#39;World&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Use of builtin <cite>range</cite> to produce a finite source stream
containing 100 <cite>int</cite> tuples from 0 to 99:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
<span class="n">hw</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
</pre></div>
</div>
<p>Use of <cite>itertools.count</cite> to produce an infinite stream of <cite>int</cite> tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
<span class="n">hw</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
</pre></div>
</div>
<p>Use of <cite>itertools</cite> to produce an infinite stream of tuples
with a constant value and a sequence number:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
<span class="n">hw</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(),</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">()))</span>
</pre></div>
</div>
<p class="rubric">External system examples</p>
<p>Typically sources pull data in from external systems, such as files,
REST apis, databases, message systems etc. Such a source will typically
be implemented as class that when called returns an iterable.</p>
<p>To allow checkpointing of state standard methods <code class="docutils literal notranslate"><span class="pre">__enter__</span></code>
and  <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> are implemented to allow creation of runtime
objects that cannot be persisted, for example a file handle.</p>
<p>At checkpoint time state is preserved through standard pickling
using <code class="docutils literal notranslate"><span class="pre">__getstate__</span></code> and (optionally) <code class="docutils literal notranslate"><span class="pre">__setstate__</span></code>.</p>
<p>Stateless source that polls a REST API every ten seconds to
get a JSON object (<cite>dict</cite>) with current time details:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">RestJsonReader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">period</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">period</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;Accept&#39;</span><span class="p">:</span> <span class="s1">&#39;application/json&#39;</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Remove the session from the persisted state</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;url&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="s1">&#39;period&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">utc_now</span> <span class="o">=</span> <span class="s1">&#39;http://worldclockapi.com/api/json/utc/now&#39;</span>
    <span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">RestJsonReader</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">utc_now</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Source functions that use generators are not supported
when checkpointing or within a consistent region. This
is because generators cannot be pickled (even when using <cite>dill</cite>).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.14: </span>Type hints are used to define the returned stream schema.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Topology.streams">
<em class="property">property </em><code class="sig-name descname">streams</code><a class="headerlink" href="#streamsx.topology.topology.Topology.streams" title="Permalink to this definition">¶</a></dt>
<dd><p>Dict of all streams in the topology.</p>
<p>Key is the name of the stream, value is the corresponding <a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Stream</span></code></a> instance.</p>
<p>The returned value is a shallow copy of current streams
in this topology. This allows callers to iterate over the copy
and perform operators that would add streams.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Includes all streams created by composites and any internal streams created by topology.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.14.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Topology.subscribe">
<code class="sig-name descname">subscribe</code><span class="sig-paren">(</span><em class="sig-param">topic</em>, <em class="sig-param">schema=&lt;CommonSchema.Python: &lt;streamsx.topology.schema.StreamSchema object&gt;&gt;</em>, <em class="sig-param">name=None</em>, <em class="sig-param">connect=None</em>, <em class="sig-param">buffer_capacity=None</em>, <em class="sig-param">buffer_full_policy=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Topology.subscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>Subscribe to a topic published by other Streams applications.
A Streams application may publish a stream to allow other
Streams applications to subscribe to it. A subscriber matches a
publisher if the topic and schema match.</p>
<p>By default a stream is subscribed as <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.Python" title="streamsx.topology.schema.CommonSchema.Python"><code class="xref py py-const docutils literal notranslate"><span class="pre">Python</span></code></a> objects
which connects to streams published to topic by Python Streams applications.</p>
<p>Structured schemas are subscribed to using an instance of
<code class="xref py py-class docutils literal notranslate"><span class="pre">StreamSchema</span></code>.  A Streams application publishing
structured schema streams may have been implemented in any
programming language supported by Streams.</p>
<p>JSON streams are subscribed to using schema <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.Json" title="streamsx.topology.schema.CommonSchema.Json"><code class="xref py py-const docutils literal notranslate"><span class="pre">Json</span></code></a>.
Each tuple on the returned stream will be a Python dictionary
object created by <code class="docutils literal notranslate"><span class="pre">json.loads(tuple)</span></code>.
A Streams application publishing JSON streams may have been implemented in any programming language
supported by Streams.</p>
<p>String streams are subscribed to using schema <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.String" title="streamsx.topology.schema.CommonSchema.String"><code class="xref py py-const docutils literal notranslate"><span class="pre">String</span></code></a>.
Each tuple on the returned stream will be a Python string object.
A Streams application publishing string streams may have been implemented in any programming language
supported by Streams.</p>
<p>Subscribers can ensure they do not slow down matching publishers
by using a buffered connection with a buffer full policy
that drops tuples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>topic</strong> (<em>str</em>) – Topic to subscribe to.</p></li>
<li><p><strong>schema</strong> (<a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.StreamSchema" title="streamsx.topology.schema.StreamSchema"><em>StreamSchema</em></a>) – schema to subscribe to.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of the subscribed stream, defaults to a generated name.</p></li>
<li><p><strong>connect</strong> (<a class="reference internal" href="#streamsx.topology.topology.SubscribeConnection" title="streamsx.topology.topology.SubscribeConnection"><em>SubscribeConnection</em></a>) – How subscriber will be connected to matching publishers. Defaults to <a class="reference internal" href="#streamsx.topology.topology.SubscribeConnection.Direct" title="streamsx.topology.topology.SubscribeConnection.Direct"><code class="xref py py-const docutils literal notranslate"><span class="pre">Direct</span></code></a> connection.</p></li>
<li><p><strong>buffer_capacity</strong> (<em>int</em>) – Buffer capacity in tuples when <cite>connect</cite> is set to <a class="reference internal" href="#streamsx.topology.topology.SubscribeConnection.Buffered" title="streamsx.topology.topology.SubscribeConnection.Buffered"><code class="xref py py-const docutils literal notranslate"><span class="pre">Buffered</span></code></a>. Defaults to 1000 when <cite>connect</cite> is <cite>Buffered</cite>. Ignored when <cite>connect</cite> is <cite>None</cite> or <cite>Direct</cite>.</p></li>
<li><p><strong>buffer_full_policy</strong> (<em>CongestionPolicy</em>) – Policy when a pulished tuple arrives and the subscriber’s buffer is full. Defaults to <cite>Wait</cite> when <cite>connect</cite> is <cite>Buffered</cite>. Ignored when <cite>connect</cite> is <cite>None</cite> or <cite>Direct</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A stream whose tuples have been published to the topic by other Streams applications.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream">Stream</a></p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.9: </span><cite>connect</cite>, <cite>buffer_capacity</cite> and <cite>buffer_full_policy</cite> parameters added.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="streamsx.topology.topology.Stream">
<em class="property">class </em><code class="sig-prename descclassname">streamsx.topology.topology.</code><code class="sig-name descname">Stream</code><span class="sig-paren">(</span><em class="sig-param">topology</em>, <em class="sig-param">oport</em>, <em class="sig-param">other=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">streamsx._streams._placement._Placement</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The Stream class is the primary abstraction within a streaming application. It represents a potentially infinite
series of tuples which can be operated upon to produce another stream, as in the case of <a class="reference internal" href="#streamsx.topology.topology.Stream.map" title="streamsx.topology.topology.Stream.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">map()</span></code></a>, or
terminate a stream, as in the case of <a class="reference internal" href="#streamsx.topology.topology.Stream.for_each" title="streamsx.topology.topology.Stream.for_each"><code class="xref py py-meth docutils literal notranslate"><span class="pre">for_each()</span></code></a>.</p>
<dl class="method">
<dt id="streamsx.topology.topology.Stream.aliased_as">
<code class="sig-name descname">aliased_as</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.aliased_as" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an alias of this stream.</p>
<p>Returns an alias of this stream with name <cite>name</cite>.
When invocation of an SPL operator requires an
<a class="reference internal" href="streamsx.spl.op.html#streamsx.spl.op.Expression" title="streamsx.spl.op.Expression"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expression</span></code></a> against
an input port this can be used to ensure expression
matches the input port alias regardless of the name
of the actual stream.</p>
<p>Example use where the filter expression for a <code class="docutils literal notranslate"><span class="pre">Filter</span></code> SPL operator
uses <code class="docutils literal notranslate"><span class="pre">IN</span></code> to access input tuple attribute <code class="docutils literal notranslate"><span class="pre">seq</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">aliased_as</span><span class="p">(</span><span class="s1">&#39;IN&#39;</span><span class="p">)</span>

<span class="n">params</span> <span class="o">=</span>  <span class="p">{</span><span class="s1">&#39;filter&#39;</span><span class="p">:</span> <span class="n">op</span><span class="o">.</span><span class="n">Expression</span><span class="o">.</span><span class="n">expression</span><span class="p">(</span><span class="s1">&#39;IN.seq </span><span class="si">% 4u</span><span class="s1">l == 0ul&#39;</span><span class="p">)}</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="s1">&#39;spl.relational::Filter&#39;</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Name for returned stream.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Alias of this stream with <code class="docutils literal notranslate"><span class="pre">name</span></code> equal to <cite>name</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream">Stream</a></p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.as_json">
<code class="sig-name descname">as_json</code><span class="sig-paren">(</span><em class="sig-param">force_object=True</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.as_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Declares a stream converting each tuple on this stream into
a JSON value.</p>
<p>The stream is typed as a <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.Json" title="streamsx.topology.schema.CommonSchema.Json"><code class="xref py py-const docutils literal notranslate"><span class="pre">JSON</span> <span class="pre">stream</span></code></a>.</p>
<p>Each tuple must be supported by <cite>JSONEncoder</cite>.</p>
<p>If <cite>force_object</cite> is <cite>True</cite> then each tuple that not a <cite>dict</cite>
will be converted to a JSON object with a single key <cite>payload</cite>
containing the tuple. Thus each object on the stream will
be a JSON object.</p>
<p>If <cite>force_object</cite> is <cite>False</cite> then each tuple is converted to
a JSON value directly using <cite>json</cite> package.</p>
<p>If this stream is already typed as a JSON stream then it will
be returned (with no additional processing against it and
<cite>force_object</cite> and <cite>name</cite> are ignored).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>force_object</strong> (<em>bool</em>) – Force conversion of non dicts to JSON objects.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of the resulting stream.
When <cite>None</cite> defaults to a generated name.</p></li>
</ul>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.1.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Stream containing the JSON representations of tuples on this stream.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream">Stream</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.as_string">
<code class="sig-name descname">as_string</code><span class="sig-paren">(</span><em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.as_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Declares a stream converting each tuple on this stream
into a string using <cite>str(tuple)</cite>.</p>
<p>The stream is typed as a <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.String" title="streamsx.topology.schema.CommonSchema.String"><code class="xref py py-const docutils literal notranslate"><span class="pre">string</span> <span class="pre">stream</span></code></a>.</p>
<p>If this stream is already typed as a string stream then it will
be returned (with no additional processing against it and <cite>name</cite>
is ignored).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Name of the resulting stream.
When <cite>None</cite> defaults to a generated name.</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.1: </span><cite>name</cite> parameter added.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Stream containing the string representations of tuples on this stream.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream">Stream</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.autonomous">
<code class="sig-name descname">autonomous</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.autonomous" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts an autonomous region for downstream processing.
By default IBM Streams processing is executed in an autonomous region
where any checkpointing of operator state is autonomous (independent)
of other operators.</p>
<p>This method may be used to end a consistent region by starting an
autonomous region. This may be called even if this stream is in
an autonomous region.</p>
<p>Autonomous is not applicable when a topology is submitted
to a STANDALONE contexts and will be ignored.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Stream whose subsequent downstream processing is in an autonomous region.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream">Stream</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.batch">
<code class="sig-name descname">batch</code><span class="sig-paren">(</span><em class="sig-param">size</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Declares a tumbling window to support batch processing
against this stream.</p>
<p>The number of tuples in the batch is defined by <cite>size</cite>.</p>
<p>If <cite>size</cite> is an <code class="docutils literal notranslate"><span class="pre">int</span></code> then it is the count of tuples in the batch.
For example, with <code class="docutils literal notranslate"><span class="pre">size=10</span></code> each batch will nominally
contain ten tuples. Thus processing against the returned
<a class="reference internal" href="#streamsx.topology.topology.Window" title="streamsx.topology.topology.Window"><code class="xref py py-class docutils literal notranslate"><span class="pre">Window</span></code></a>, such as <a class="reference internal" href="#streamsx.topology.topology.Window.aggregate" title="streamsx.topology.topology.Window.aggregate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aggregate()</span></code></a> will be
executed every ten tuples against the last ten tuples on the stream.
For example the first three aggregations would be against
the first ten tuples on the stream, then the next ten tuples
and then the third ten tuples, etc.</p>
<p>If <cite>size</cite> is an <cite>datetime.timedelta</cite> then it is the duration
of the batch using wallclock time.
With a <cite>timedelta</cite> representing five minutes
then the window contains any tuples that arrived in the last
five minutes.  Thus processing against the returned <a class="reference internal" href="#streamsx.topology.topology.Window" title="streamsx.topology.topology.Window"><code class="xref py py-class docutils literal notranslate"><span class="pre">Window</span></code></a>,
such as <a class="reference internal" href="#streamsx.topology.topology.Window.aggregate" title="streamsx.topology.topology.Window.aggregate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aggregate()</span></code></a> will be executed every five minutes tuples
against the batch of tuples arriving in the last five minutes
on the stream. For example the first three aggregations would be
against any tuples on the stream in the first five minutes,
then the next five minutes and then minutes ten to fifteen.
A batch can contain no tuples if no tuples arrived on the stream
in the defined duration.</p>
<p>For specifying the duration of the window with a submission parameter use <a class="reference internal" href="#streamsx.topology.topology.Stream.batchSeconds" title="streamsx.topology.topology.Stream.batchSeconds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">batchSeconds()</span></code></a>.</p>
<p>Each tuple on the stream appears only in a single batch.</p>
<p>The number of tuples seen by processing against the
returned window may be less than <cite>size</cite> (count or time based)
when:</p>
<blockquote>
<div><ul class="simple">
<li><p>the stream is finite, the final batch may contain less tuples than the defined size,</p></li>
<li><p>the stream is in a consistent region, drain processing will complete the current batch without waiting for it to batch to reach its nominal size.</p></li>
</ul>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create batches against stream s of 100 tuples each</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a window size specified by submission parameter</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">create_submission_parameter</span><span class="p">(</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create batches against stream s every five minutes</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a tumbling punctuation-based window</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="s1">&#39;punct&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>size</strong> (int|datetime.timedelta|submission parameter created by <a class="reference internal" href="#streamsx.topology.topology.Topology.create_submission_parameter" title="streamsx.topology.topology.Topology.create_submission_parameter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Topology.create_submission_parameter()</span></code></a>) – The size of each batch, either an <cite>int</cite> to define the
number of tuples or <cite>datetime.timedelta</cite> to define the
duration of the batch or
submission parameter created by <a class="reference internal" href="#streamsx.topology.topology.Topology.create_submission_parameter" title="streamsx.topology.topology.Topology.create_submission_parameter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Topology.create_submission_parameter()</span></code></a>
to define the number of tuples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Window allowing batch processing on this stream.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#streamsx.topology.topology.Window" title="streamsx.topology.topology.Window">Window</a></p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.11.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.batchSeconds">
<code class="sig-name descname">batchSeconds</code><span class="sig-paren">(</span><em class="sig-param">size</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.batchSeconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Declares a tumbling window to support batch processing
against this stream using a submission parameter created by
<a class="reference internal" href="#streamsx.topology.topology.Topology.create_submission_parameter" title="streamsx.topology.topology.Topology.create_submission_parameter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Topology.create_submission_parameter()</span></code></a>.</p>
<p>The number of tuples in the batch is defined by <cite>size</cite> in seconds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>size</strong> (submission parameter created by <a class="reference internal" href="#streamsx.topology.topology.Topology.create_submission_parameter" title="streamsx.topology.topology.Topology.create_submission_parameter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Topology.create_submission_parameter()</span></code></a>) – The size of the window in seconds.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a tumbling window with submission parameter `time` and the default value 10 seconds</span>
<span class="n">time</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">create_submission_parameter</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">batchSeconds</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a window with submission parameter `secs` and no default value</span>
<span class="n">time</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">create_submission_parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;secs&#39;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">batchSeconds</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Window allowing batch processing on this stream.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#streamsx.topology.topology.Window" title="streamsx.topology.topology.Window">Window</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.category">
<em class="property">property </em><code class="sig-name descname">category</code><a class="headerlink" href="#streamsx.topology.topology.Stream.category" title="Permalink to this definition">¶</a></dt>
<dd><p>Category for this processing logic.</p>
<p>An arbitrary application label allowing grouping of application
elements by category.</p>
<p>Assign categories based on common function.
For example, <cite>database</cite> is a common category that you can
use to group all database sinks in an application.</p>
<p>A category is not required and defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code> meaning
no assigned category.</p>
<p>Streams console supports visualization based upon categories.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>TypeError</strong> – No directly associated processing logic.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A category has no affect on the execution of the application.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.colocate">
<code class="sig-name descname">colocate</code><span class="sig-paren">(</span><em class="sig-param">others</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.colocate" title="Permalink to this definition">¶</a></dt>
<dd><p>Colocate this processing logic with others.</p>
<p>Colocating processing logic requires execution in
the same Streams processing element (operating system process).</p>
<p>When a job is submitted Streams may colocate (fuse) processing
logic into the same processing element based upon flow analysis
and current resource usage. This call instructs that this logic
and <cite>others</cite> must be executed in the same processing element.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>others</strong> – Processing logic such as a
<a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>
or <a class="reference internal" href="#streamsx.topology.topology.Sink" title="streamsx.topology.topology.Sink"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sink</span></code></a>.
A single value can be passed or an iterable, such
as a list of streams.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>This logic.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.end_low_latency">
<code class="sig-name descname">end_low_latency</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.end_low_latency" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Stream that is no longer guaranteed to run in the same process
as the calling stream.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Stream</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.end_parallel">
<code class="sig-name descname">end_parallel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.end_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Ends a parallel region by merging the channels into a single stream.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Stream for which subsequent transformations are no longer parallelized.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream">Stream</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#streamsx.topology.topology.Stream.set_parallel" title="streamsx.topology.topology.Stream.set_parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_parallel()</span></code></a>, <a class="reference internal" href="#streamsx.topology.topology.Stream.parallel" title="streamsx.topology.topology.Stream.parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parallel()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.filter">
<code class="sig-name descname">filter</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">non_matching=False</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filters tuples from this stream using the supplied callable <cite>func</cite>.</p>
<p>For each stream tuple <cite>t</cite> on the stream <code class="docutils literal notranslate"><span class="pre">func(t)</span></code> is called, if the return evaluates to <code class="docutils literal notranslate"><span class="pre">True</span></code> the
tuple will be present on the returned stream, otherwise the tuple is filtered out.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – Filter callable that takes a single parameter for the stream tuple.</p></li>
<li><p><strong>non_matching</strong> (<em>bool</em>) – Non-matching tuples are sent to a second optional output stream</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of the stream, defaults to a generated name.</p></li>
</ul>
</dd>
</dl>
<p>If invoking <code class="docutils literal notranslate"><span class="pre">func</span></code> for a stream tuple raises an exception
then its processing element will terminate. By default the processing
element will automatically restart though tuples may be lost.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">func</span></code> is a callable object then it may suppress exceptions
by return a true value from its <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> method. When an
exception is suppressed no tuple is submitted to the filtered
stream corresponding to the input tuple that caused the exception.</p>
<p>Example with matching and non matching streams:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">source</span><span class="p">([</span><span class="s1">&#39;Hello&#39;</span><span class="p">,</span> <span class="s1">&#39;World&#39;</span><span class="p">])</span>
<span class="n">matches</span><span class="p">,</span> <span class="n">non_matches</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">filter</span><span class="p">((</span><span class="k">lambda</span> <span class="n">t</span> <span class="p">:</span> <span class="s2">&quot;Wor&quot;</span> <span class="ow">in</span> <span class="n">t</span><span class="p">),</span> <span class="n">non_matching</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A Stream containing tuples that have not been filtered out. The schema of the returned stream is the same as this stream’s schema. Optional second stream is returned for non matching tuples, if parameter non_matching is set to True.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream">Stream</a></p>
</dd>
</dl>
<p class="rubric">Type hints</p>
<p>The argument type hint on <cite>func</cite> is used (if present) to verify
at topology declaration time that it is compatible with the
type of tuples on this stream.</p>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.flat_map">
<code class="sig-name descname">flat_map</code><span class="sig-paren">(</span><em class="sig-param">func=None</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.flat_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps and flatterns each tuple from this stream into 0 or more tuples.</p>
<p>For each tuple on this stream <code class="docutils literal notranslate"><span class="pre">func(tuple)</span></code> is called.
If the result is not <cite>None</cite> then the the result is iterated over
with each value from the iterator that is not <cite>None</cite> will be submitted
to the return stream.</p>
<p>If the result is <cite>None</cite> or an empty iterable then no tuples are submitted to
the returned stream.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – A callable that takes a single parameter for the tuple.
If not supplied then a function equivalent to <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">tuple_</span> <span class="pre">:</span> <span class="pre">tuple_</span></code> is used.
This is suitable when each tuple on this stream is an iterable to be flattened.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of the flattened stream, defaults to a generated name.</p></li>
</ul>
</dd>
</dl>
<p>If invoking <code class="docutils literal notranslate"><span class="pre">func</span></code> for a tuple on the stream raises an exception
then its processing element will terminate. By default the processing
element will automatically restart though tuples may be lost.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">func</span></code> is a callable object then it may suppress exceptions
by return a true value from its <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> method. When an
exception is suppressed no tuples are submitted to the flattened
and mapped stream corresponding to the input tuple
that caused the exception.</p>
<p>Example: For a list of dict the <code class="docutils literal notranslate"><span class="pre">flat_map</span></code> emits <strong>n</strong> tuples for each input tuple received, with <strong>n</strong> the number of elements in the list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">NamedTuple</span>

<span class="k">class</span> <span class="nc">SampleSchema</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">flag</span><span class="p">:</span> <span class="nb">bool</span>

<span class="k">def</span> <span class="nf">flatten_dict</span><span class="p">(</span><span class="n">tpl</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">SampleSchema</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">tpl</span>

<span class="c1"># list_stream is a stream of list from dict as Python object, for example [{&#39;id&#39;: &#39;0&#39;, &#39;flag&#39;:True}]</span>
<span class="n">sample_stream</span> <span class="o">=</span> <span class="n">list_stream</span><span class="o">.</span><span class="n">flat_map</span><span class="p">(</span><span class="n">flatten_dict</span><span class="p">)</span> <span class="c1"># sample_stream is a named tuple stream of SampleSchema</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A Stream containing flattened and mapped tuples.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream">Stream</a></p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>TypeError</strong> – if <cite>func</cite> does not return an iterator nor None</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.11: </span><cite>func</cite> is optional.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.for_each">
<code class="sig-name descname">for_each</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">name=None</em>, <em class="sig-param">process_punct=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.for_each" title="Permalink to this definition">¶</a></dt>
<dd><p>Sends information as a stream to an external system.</p>
<p>The transformation defined by <cite>func</cite> is a callable
or a composite transformation.</p>
<p class="rubric">Callable transformation</p>
<p>If <cite>func</cite> is callable then for each tuple <cite>t</cite> on this
stream <code class="docutils literal notranslate"><span class="pre">func(t)</span></code> is called.</p>
<p>If invoking <code class="docutils literal notranslate"><span class="pre">func</span></code> for a tuple on the stream raises an exception
then its processing element will terminate. By default the processing
element will automatically restart though tuples may be lost.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">func</span></code> is a callable object then it may suppress exceptions
by return a true value from its <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> method. When an
exception is suppressed no further processing occurs for the
input tuple that caused the exception.</p>
<p>Example with class handling punctuations in the Sink operator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FEClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">on_punct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;window punctuation marker received&#39;</span><span class="p">)</span>
        <span class="o">...</span>

<span class="o">...</span>
<span class="n">s</span><span class="o">.</span><span class="n">for_each</span><span class="p">(</span><span class="n">FEClass</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;SinkHandlingPunctuations&#39;</span><span class="p">,</span> <span class="n">process_punct</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Composite transformation</p>
<p>A composite transformation is an instance of <a class="reference internal" href="streamsx.topology.composite.html#streamsx.topology.composite.ForEach" title="streamsx.topology.composite.ForEach"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForEach</span></code></a>. Composites allow the application developer to use
the standard functional style of the topology api while allowing
allowing expansion of a <cite>for_each</cite> transform to multiple basic
transformations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – A callable that takes a single parameter for the tuple and returns None.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of the stream, defaults to a generated name.</p></li>
<li><p><strong>process_punct</strong> (<em>bool</em>) – Specifies if <code class="docutils literal notranslate"><span class="pre">on_punct</span></code> on callable <code class="docutils literal notranslate"><span class="pre">func</span></code> is called when window punctuation markers are received.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Stream termination.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#streamsx.topology.topology.Sink" title="streamsx.topology.topology.Sink">streamsx.topology.topology.Sink</a></p>
</dd>
</dl>
<p class="rubric">Type hints</p>
<p>The argument type hint on <cite>func</cite> is used (if present) to verify
at topology declaration time that it is compatible with the
type of tuples on this stream.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.7: </span>Now returns a <a class="reference internal" href="#streamsx.topology.topology.Sink" title="streamsx.topology.topology.Sink"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sink</span></code></a> instance.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.14: </span>Support for type hints and composite transformations.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.16: </span>New parameter process_punct to support handling of window punctuation markers in callable.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.isolate">
<code class="sig-name descname">isolate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.isolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Guarantees that the upstream operation will run in a separate processing element from the downstream operation</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Stream whose subsequent immediate processing will occur in a separate processing element.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream">Stream</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.last">
<code class="sig-name descname">last</code><span class="sig-paren">(</span><em class="sig-param">size=1</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.last" title="Permalink to this definition">¶</a></dt>
<dd><p>Declares a slding window containing most recent tuples
on this stream.</p>
<p>The number of tuples maintained in the window is defined by <cite>size</cite>.</p>
<p>If <cite>size</cite> is an <cite>int</cite> then it is the count of tuples in the window.
For example, with <code class="docutils literal notranslate"><span class="pre">size=10</span></code> the window always contains the
last (most recent) ten tuples.</p>
<p>If <cite>size</cite> is an <cite>datetime.timedelta</cite> then it is the duration
of the window. With a <cite>timedelta</cite> representing five minutes
then the window contains any tuples that arrived in the last
five minutes.</p>
<p>If <cite>size</cite> is an <cite>submission parameter</cite> created by <a class="reference internal" href="#streamsx.topology.topology.Topology.create_submission_parameter" title="streamsx.topology.topology.Topology.create_submission_parameter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Topology.create_submission_parameter()</span></code></a> then it is the count of tuples in the window.
For specifying the duration of the window with a submission parameter use <a class="reference internal" href="#streamsx.topology.topology.Stream.lastSeconds" title="streamsx.topology.topology.Stream.lastSeconds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lastSeconds()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>size</strong> (int|datetime.timedelta|submission parameter created by <a class="reference internal" href="#streamsx.topology.topology.Topology.create_submission_parameter" title="streamsx.topology.topology.Topology.create_submission_parameter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Topology.create_submission_parameter()</span></code></a>) – The size of the window, either an <cite>int</cite> to define the
number of tuples or <cite>datetime.timedelta</cite> to define the
duration of the window or
submission parameter created by <a class="reference internal" href="#streamsx.topology.topology.Topology.create_submission_parameter" title="streamsx.topology.topology.Topology.create_submission_parameter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Topology.create_submission_parameter()</span></code></a>
to define the number of tuples.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a window against stream s of the last 100 tuples</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a window against stream s of the last n tuples specified by submission parameter</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">create_submission_parameter</span><span class="p">(</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a window against stream s of tuples</span>
<span class="c1"># arrived on the stream in the last five minutes</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Window of the last (most recent) tuples on this stream.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#streamsx.topology.topology.Window" title="streamsx.topology.topology.Window">Window</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.lastSeconds">
<code class="sig-name descname">lastSeconds</code><span class="sig-paren">(</span><em class="sig-param">size</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.lastSeconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Declares a slding window containing most recent tuples
on this stream using a submission parameter created by
<a class="reference internal" href="#streamsx.topology.topology.Topology.create_submission_parameter" title="streamsx.topology.topology.Topology.create_submission_parameter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Topology.create_submission_parameter()</span></code></a>.</p>
<p>The number of tuples maintained in the window is defined by <cite>size</cite> in seconds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>size</strong> (submission parameter created by <a class="reference internal" href="#streamsx.topology.topology.Topology.create_submission_parameter" title="streamsx.topology.topology.Topology.create_submission_parameter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Topology.create_submission_parameter()</span></code></a>) – The size of the window in seconds.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a window against stream s of the last with submission parameter `time` and the default value 10 seconds</span>
<span class="n">time</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">create_submission_parameter</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">lastSeconds</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a window with submission parameter `secs` and no default value</span>
<span class="n">time</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">create_submission_parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;secs&#39;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">lastSeconds</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Window of the last (most recent) tuples on this stream.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#streamsx.topology.topology.Window" title="streamsx.topology.topology.Window">Window</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.low_latency">
<code class="sig-name descname">low_latency</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.low_latency" title="Permalink to this definition">¶</a></dt>
<dd><p>The function is guaranteed to run in the same process as the
upstream Stream function. All streams that are created from the returned stream
are also guaranteed to run in the same process until end_low_latency()
is called.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Stream</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.map">
<code class="sig-name descname">map</code><span class="sig-paren">(</span><em class="sig-param">func=None</em>, <em class="sig-param">name=None</em>, <em class="sig-param">schema=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps each tuple from this stream into 0 or 1 stream tuples.</p>
<p>The transformation defined by <cite>func</cite> is a callable
or a composite transformation.</p>
<p class="rubric">Callable transformation</p>
<p>For each tuple on this stream <code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">func(tuple)</span></code> is called.
If <cite>result</cite> is not <cite>None</cite> then the result will be submitted
as a tuple on the returned stream. If <cite>result</cite> is <cite>None</cite> then
no tuple submission will occur.</p>
<p>By default the submitted tuple is <code class="docutils literal notranslate"><span class="pre">result</span></code> without modification
resulting in a stream of picklable Python objects. Setting the
<cite>schema</cite> parameter changes the type of the stream and
modifies each <code class="docutils literal notranslate"><span class="pre">result</span></code> before submission.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">object</span></code> or <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.Python" title="streamsx.topology.schema.CommonSchema.Python"><code class="xref py py-const docutils literal notranslate"><span class="pre">Python</span></code></a> - The default:  <cite>result</cite> is submitted.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code> type or <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.String" title="streamsx.topology.schema.CommonSchema.String"><code class="xref py py-const docutils literal notranslate"><span class="pre">String</span></code></a> - A stream of strings: <code class="docutils literal notranslate"><span class="pre">str(result)</span></code> is submitted.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">json</span></code> or <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.Json" title="streamsx.topology.schema.CommonSchema.Json"><code class="xref py py-const docutils literal notranslate"><span class="pre">Json</span></code></a> - A stream of JSON objects: <code class="docutils literal notranslate"><span class="pre">result</span></code> must be convertable to a JSON object using <cite>json</cite> package.</p></li>
<li><p><a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.StreamSchema" title="streamsx.topology.schema.StreamSchema"><code class="xref py py-const docutils literal notranslate"><span class="pre">StreamSchema</span></code></a> - A structured stream. <cite>result</cite> must be a <cite>dict</cite> or (Python) <cite>tuple</cite>. When a <cite>dict</cite> is returned the outgoing stream tuple attributes are set by name, when a <cite>tuple</cite> is returned stream tuple attributes are set by position.</p></li>
<li><p>string value - Equivalent to passing <code class="docutils literal notranslate"><span class="pre">StreamSchema(schema)</span></code></p></li>
</ul>
<p class="rubric">Composite transformation</p>
<p>A composite transformation is an instance of <a class="reference internal" href="streamsx.topology.composite.html#streamsx.topology.composite.Map" title="streamsx.topology.composite.Map"><code class="xref py py-class docutils literal notranslate"><span class="pre">Map</span></code></a>. Composites allow the application developer to use
the standard functional style of the topology api while allowing
allowing expansion of a <cite>map</cite> transform to multiple basic
transformations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – A callable that takes a single parameter for the tuple.
If not supplied then a function equivalent to <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">tuple_</span> <span class="pre">:</span> <span class="pre">tuple_</span></code> is used.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of the mapped stream, defaults to a generated name.</p></li>
<li><p><strong>schema</strong> (<em>StreamSchema|CommonSchema|str</em>) – Schema of the resulting stream.</p></li>
</ul>
</dd>
</dl>
<p>If invoking <code class="docutils literal notranslate"><span class="pre">func</span></code> for a tuple on the stream raises an exception
then its processing element will terminate. By default the processing
element will automatically restart though tuples may be lost.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">func</span></code> is a callable object then it may suppress exceptions
by return a true value from its <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> method. When an
exception is suppressed no tuple is submitted to the mapped
stream corresponding to the input tuple that caused the exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A stream containing tuples mapped by <cite>func</cite>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream">Stream</a></p>
</dd>
</dl>
<p class="rubric">Type hints</p>
<p>If <cite>schema</cite> is not set then the return type hint on <cite>func</cite> define the
schema of the returned stream, defaulting to
<a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.Python" title="streamsx.topology.schema.CommonSchema.Python"><code class="xref py py-const docutils literal notranslate"><span class="pre">Python</span></code></a> if no
type hints are present.</p>
<p>For example <cite>reading_from_json</cite> has a type hint that
defines it as returning <code class="docutils literal notranslate"><span class="pre">SensorReading</span></code> instances (typed named tuples).
Thus <cite>readings</cite> has a structured schema matching <code class="docutils literal notranslate"><span class="pre">SensorReading</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">reading_from_json</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SensorReading</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">SensorReading</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="s1">&#39;reading&#39;</span><span class="p">])</span>

<span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
<span class="n">json_readings</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">HttpReadings</span><span class="p">())</span><span class="o">.</span><span class="n">as_json</span><span class="p">()</span>
<span class="n">readings</span> <span class="o">=</span> <span class="n">json_readings</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">reading_from_json</span><span class="p">)</span>
</pre></div>
</div>
<p>The argument type hint on <cite>func</cite> is used (if present) to verify
at topology declaration time that it is compatible with the
type of tuples on this stream.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7: </span><cite>schema</cite> argument added to allow conversion to
a structured stream.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8: </span>Support for submitting <cite>dict</cite> objects as stream tuples to a structured stream (in addition to existing support for <cite>tuple</cite> objects).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.11: </span><cite>func</cite> is optional.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#streamsx.topology.topology.Stream.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Unique name of the stream.</p>
<p>When declaring a stream a <cite>name</cite> parameter can be provided.
If the supplied name is unique within its topology then
it will be used as-is, otherwise a variant will be provided
that is unique within the topology.</p>
<p>If a <cite>name</cite> parameter was not provided when declaring a stream
then the stream is assigned a unique generated name.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Name of the stream.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#streamsx.topology.topology.Stream.aliased_as" title="streamsx.topology.topology.Stream.aliased_as"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aliased_as()</span></code></a></p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If the name is not a valid SPL identifier or longer than
80 characters then the name will be
converted to a valid SPL identifier at compile and runtime.
This identifier will be the name used in the REST api and log/trace.</p>
<p>Visualizations of the runtime graph uses <cite>name</cite> rather
than the converted identifier.</p>
<p>A valid SPL identifier consists only of
characters <code class="docutils literal notranslate"><span class="pre">A-Z</span></code>, <code class="docutils literal notranslate"><span class="pre">a-z</span></code>, <code class="docutils literal notranslate"><span class="pre">0-9</span></code>, <code class="docutils literal notranslate"><span class="pre">_</span></code> and
must not start with a number or be an SPL keyword.</p>
<p>See <a class="reference internal" href="#streamsx.topology.topology.Stream.runtime_id" title="streamsx.topology.topology.Stream.runtime_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">runtime_id</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.parallel">
<code class="sig-name descname">parallel</code><span class="sig-paren">(</span><em class="sig-param">width</em>, <em class="sig-param">routing=&lt;Routing.ROUND_ROBIN: 1&gt;</em>, <em class="sig-param">func=None</em>, <em class="sig-param">keys=None</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Split stream into channels and start a parallel region.</p>
<p>Returns a new stream that will contain the contents of
this stream with tuples distributed across its channels.</p>
<p>The returned stream starts a parallel region where all
downstream transforms are replicated across <cite>width</cite> channels.
A parallel region is terminated by <a class="reference internal" href="#streamsx.topology.topology.Stream.end_parallel" title="streamsx.topology.topology.Stream.end_parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">end_parallel()</span></code></a>
or <a class="reference internal" href="#streamsx.topology.topology.Stream.for_each" title="streamsx.topology.topology.Stream.for_each"><code class="xref py py-meth docutils literal notranslate"><span class="pre">for_each()</span></code></a>.</p>
<p>Any transform (such as <a class="reference internal" href="#streamsx.topology.topology.Stream.map" title="streamsx.topology.topology.Stream.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">map()</span></code></a>, <a class="reference internal" href="#streamsx.topology.topology.Stream.filter" title="streamsx.topology.topology.Stream.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a>, etc.) in
a parallel region has a copy of its callable executing
independently in parallel. Channels remain independent
of other channels until the region is terminated.</p>
<p>For example with this topology fragment a parallel region
of width 3 is created:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">parallel</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">F</span><span class="p">())</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">M</span><span class="p">())</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">end_parallel</span><span class="p">()</span>
<span class="n">e</span><span class="o">.</span><span class="n">for_each</span><span class="p">(</span><span class="n">E</span><span class="p">())</span>
</pre></div>
</div>
<p>Tuples from <code class="docutils literal notranslate"><span class="pre">p</span></code> (parallelized <code class="docutils literal notranslate"><span class="pre">s</span></code>)  are distributed
across three channels, 0, 1 &amp; 2
and are independently processed by three instances of <code class="docutils literal notranslate"><span class="pre">F</span></code> and <code class="docutils literal notranslate"><span class="pre">M</span></code>.
The tuples that pass the filter <code class="docutils literal notranslate"><span class="pre">F</span></code> in channel 0 are then mapped
by the instance of <code class="docutils literal notranslate"><span class="pre">M</span></code> in channel 0, and so on for channels 1 and 2.</p>
<p>The channels are combined by <code class="docutils literal notranslate"><span class="pre">end_parallel</span></code> and so a single instance
of <code class="docutils literal notranslate"><span class="pre">E</span></code> processes all the tuples from channels 0, 1 &amp; 2.</p>
<p>This stream instance (the original) is outside of the parallel region
and so any downstream transforms are executed normally.
Adding this <cite>map</cite> transform would result in tuples
on <code class="docutils literal notranslate"><span class="pre">s</span></code> being processed by a single instance of <code class="docutils literal notranslate"><span class="pre">N</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">N</span><span class="p">())</span>
</pre></div>
</div>
<p>The number of channels is set by <cite>width</cite> which may be an <cite>int</cite> greater
than zero or a submission parameter created by
<a class="reference internal" href="#streamsx.topology.topology.Topology.create_submission_parameter" title="streamsx.topology.topology.Topology.create_submission_parameter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Topology.create_submission_parameter()</span></code></a>.</p>
<p>With IBM Streams 4.3 or later the number of channels can be
dynamically changed at runtime.</p>
<p>Tuples are routed to channels based upon <cite>routing</cite>, see <a class="reference internal" href="#streamsx.topology.topology.Routing" title="streamsx.topology.topology.Routing"><code class="xref py py-class docutils literal notranslate"><span class="pre">Routing</span></code></a>.</p>
<p>A parallel region can have multiple termination points, for
example when a stream within the stream has multiple transforms
against it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">parallel</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">m1p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">M1</span><span class="p">())</span>
<span class="n">m2p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">M2</span><span class="p">())</span>
<span class="n">p</span><span class="o">.</span><span class="n">for_each</span><span class="p">(</span><span class="n">E</span><span class="p">())</span>

<span class="n">m1</span> <span class="o">=</span> <span class="n">m1p</span><span class="o">.</span><span class="n">end_parallel</span><span class="p">()</span>
<span class="n">m2</span> <span class="o">=</span> <span class="n">m2p</span><span class="o">.</span><span class="n">end_parallel</span><span class="p">()</span>
</pre></div>
</div>
<p>Parallel regions can be nested, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">parallel</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">MO</span><span class="p">())</span><span class="o">.</span><span class="n">parallel</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">MI</span><span class="p">())</span><span class="o">.</span><span class="n">end_parallel</span><span class="p">()</span><span class="o">.</span><span class="n">end_parallel</span><span class="p">()</span>
</pre></div>
</div>
<p>In this case there will be two instances of <code class="docutils literal notranslate"><span class="pre">MO</span></code> (the outer region) and six (2x3) instances of <code class="docutils literal notranslate"><span class="pre">MI</span></code> (the inner region).</p>
<p>Streams created by <a class="reference internal" href="#streamsx.topology.topology.Topology.source" title="streamsx.topology.topology.Topology.source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">source()</span></code></a> or
<a class="reference internal" href="#streamsx.topology.topology.Topology.subscribe" title="streamsx.topology.topology.Topology.subscribe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subscribe()</span></code></a> are placed in a parallel region
by <a class="reference internal" href="#streamsx.topology.topology.Stream.set_parallel" title="streamsx.topology.topology.Stream.set_parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_parallel()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>width</strong> (int|submission parameter created by <a class="reference internal" href="#streamsx.topology.topology.Topology.create_submission_parameter" title="streamsx.topology.topology.Topology.create_submission_parameter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Topology.create_submission_parameter()</span></code></a>) – Degree of parallelism.</p></li>
<li><p><strong>routing</strong> (<a class="reference internal" href="#streamsx.topology.topology.Routing" title="streamsx.topology.topology.Routing"><em>Routing</em></a>) – Denotes what type of tuple routing to use.</p></li>
<li><p><strong>func</strong> – Optional function called when <a class="reference internal" href="#streamsx.topology.topology.Routing.HASH_PARTITIONED" title="streamsx.topology.topology.Routing.HASH_PARTITIONED"><code class="xref py py-const docutils literal notranslate"><span class="pre">Routing.HASH_PARTITIONED</span></code></a> routing is specified.
The function provides an integer value to be used as the hash that determines
the tuple channel routing.</p></li>
<li><p><strong>keys</strong> (<em>[</em><em>str</em><em>]</em>) – Optional list of keys required when <a class="reference internal" href="#streamsx.topology.topology.Routing.KEY_PARTITIONED" title="streamsx.topology.topology.Routing.KEY_PARTITIONED"><code class="xref py py-const docutils literal notranslate"><span class="pre">Routing.KEY_PARTITIONED</span></code></a> routing is specified. Each key represents a tuple attribute.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – The name to display for the parallel region.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A stream for which subsequent transformations will be executed in parallel.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream">Stream</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#streamsx.topology.topology.Stream.set_parallel" title="streamsx.topology.topology.Stream.set_parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_parallel()</span></code></a>, <a class="reference internal" href="#streamsx.topology.topology.Stream.end_parallel" title="streamsx.topology.topology.Stream.end_parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">end_parallel()</span></code></a>, <a class="reference internal" href="#streamsx.topology.topology.Stream.split" title="streamsx.topology.topology.Stream.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.print">
<code class="sig-name descname">print</code><span class="sig-paren">(</span><em class="sig-param">tag=None</em>, <em class="sig-param">name=None</em>, <em class="sig-param">write_punctuations=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.print" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints each tuple to stdout flushing after each tuple.</p>
<p>If <cite>tag</cite> is not <cite>None</cite> then each tuple has “tag: ” prepended
to it before printing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tag</strong> – A tag to prepend to each tuple.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of the resulting stream.
When <cite>None</cite> defaults to a generated name.</p></li>
<li><p><strong>write_punctuations</strong> (<em>bool</em>) – Specifies to write punctuations to stdout</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Stream termination.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#streamsx.topology.topology.Sink" title="streamsx.topology.topology.Sink">streamsx.topology.topology.Sink</a></p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.1: </span><cite>tag</cite>, <cite>name</cite> parameters.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.7: </span>Now returns a <a class="reference internal" href="#streamsx.topology.topology.Sink" title="streamsx.topology.topology.Sink"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sink</span></code></a> instance.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.16: </span><cite>write_punctuations</cite> parameter.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.publish">
<code class="sig-name descname">publish</code><span class="sig-paren">(</span><em class="sig-param">topic</em>, <em class="sig-param">schema=None</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.publish" title="Permalink to this definition">¶</a></dt>
<dd><p>Publish this stream on a topic for other Streams applications to subscribe to.
A Streams application may publish a stream to allow other
Streams applications to subscribe to it. A subscriber
matches a publisher if the topic and schema match.</p>
<p>By default a stream is published using its schema.</p>
<p>A stream of <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.Python" title="streamsx.topology.schema.CommonSchema.Python"><code class="xref py py-const docutils literal notranslate"><span class="pre">Python</span> <span class="pre">objects</span></code></a> can be subscribed to by other Streams Python applications.</p>
<p>If a stream is published setting <cite>schema</cite> to
<code class="docutils literal notranslate"><span class="pre">json</span></code> or <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.Json" title="streamsx.topology.schema.CommonSchema.Json"><code class="xref py py-const docutils literal notranslate"><span class="pre">Json</span></code></a>
then it is published as a stream of JSON objects.
Other Streams applications may subscribe to it regardless
of their implementation language.</p>
<p>If a stream is published setting <cite>schema</cite> to
<code class="docutils literal notranslate"><span class="pre">str</span></code> or <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.String" title="streamsx.topology.schema.CommonSchema.String"><code class="xref py py-const docutils literal notranslate"><span class="pre">String</span></code></a>
then it is published as strings.
Other Streams applications may subscribe to it regardless
of their implementation language.</p>
<p>Supported values of <cite>schema</cite> are only
<code class="docutils literal notranslate"><span class="pre">json</span></code>, <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.Json" title="streamsx.topology.schema.CommonSchema.Json"><code class="xref py py-const docutils literal notranslate"><span class="pre">Json</span></code></a>
and
<code class="docutils literal notranslate"><span class="pre">str</span></code>, <a class="reference internal" href="streamsx.topology.schema.html#streamsx.topology.schema.CommonSchema.String" title="streamsx.topology.schema.CommonSchema.String"><code class="xref py py-const docutils literal notranslate"><span class="pre">String</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>topic</strong> (<em>str</em>) – Topic to publish this stream to.</p></li>
<li><p><strong>schema</strong> – Schema to publish. Defaults to the schema of this stream.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of the publish operator, defaults to a generated name.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Stream termination.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#streamsx.topology.topology.Sink" title="streamsx.topology.topology.Sink">streamsx.topology.topology.Sink</a></p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.1: </span><cite>name</cite> parameter.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.7: </span>Now returns a <a class="reference internal" href="#streamsx.topology.topology.Sink" title="streamsx.topology.topology.Sink"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sink</span></code></a> instance.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.punctor">
<code class="sig-name descname">punctor</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">before=True</em>, <em class="sig-param">replace=False</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.punctor" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds window punctuation to this stream using the supplied callable <cite>func</cite> as condition that determines when a window punctuation is to be generated.</p>
<p>For each stream tuple <cite>t</cite> on the stream <code class="docutils literal notranslate"><span class="pre">func(t)</span></code> is called, if the return evaluates to <code class="docutils literal notranslate"><span class="pre">True</span></code> the
window punctuation will be generated and the tuple is forwarded, otherwise the tuple is just forwarded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – Punctor callable that takes a single parameter for the stream tuple.</p></li>
<li><p><strong>before</strong> (<em>bool</em>) – If the value is <cite>True</cite>, the punctuation is generated before the output tuple; otherwise it is generated after the output tuple.</p></li>
<li><p><strong>replace</strong> (<em>bool</em>) – If the value is <cite>True</cite>, then in case <code class="docutils literal notranslate"><span class="pre">func(t)</span></code> returns <code class="docutils literal notranslate"><span class="pre">True</span></code> the window punctuation will be generated and the tuple is discarded (not forwarded). The parameter <code class="docutils literal notranslate"><span class="pre">before</span></code> is not ignored in this case.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of the stream, defaults to a generated name.</p></li>
</ul>
</dd>
</dl>
<p>If invoking <code class="docutils literal notranslate"><span class="pre">func</span></code> for a stream tuple raises an exception
then its processing element will terminate. By default the processing
element will automatically restart though tuples may be lost.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">func</span></code> is a callable object then it may suppress exceptions
by return a true value from its <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> method. When an
exception is suppressed no tuple is submitted to the output
stream corresponding to the input tuple that caused the exception.</p>
<p>Example with adding punctuation after each tuple:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">source</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">punctor</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Example with sending punctuation before a tuple:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">source</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">punctor</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A Stream containing tuples with generated punctuation. The schema of the returned stream is the same as this stream’s schema.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream">Stream</a></p>
</dd>
</dl>
<p class="rubric">Type hints</p>
<p>The argument type hint on <cite>func</cite> is used (if present) to verify
at topology declaration time that it is compatible with the
type of tuples on this stream.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.16.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.resource_tags">
<em class="property">property </em><code class="sig-name descname">resource_tags</code><a class="headerlink" href="#streamsx.topology.topology.Stream.resource_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource tags for this processing logic.</p>
<p>Tags are a mechanism for differentiating and identifying resources that have different physical characteristics or logical uses. For example a resource (host) that has external connectivity for public data sources may be tagged <cite>ingest</cite>.</p>
<p>Processing logic can be associated with one or more tags to require
running on suitably tagged resources. For example
adding tags <cite>ingest</cite> and <cite>db</cite> requires that the processing element
containing the callable that created the stream runs on a host
tagged with both <cite>ingest</cite> and <cite>db</cite>.</p>
<p>A <a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> that was not created directly with a Python callable
cannot have tags associated with it. For example a stream that
is a <a class="reference internal" href="#streamsx.topology.topology.Stream.union" title="streamsx.topology.topology.Stream.union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">union()</span></code></a> of multiple streams cannot be tagged.
In this case this method returns an empty <cite>frozenset</cite> which
cannot be modified.</p>
<p>See <a class="reference external" href="https://www.ibm.com/support/knowledgecenter/en/SSCRJU_4.2.1/com.ibm.streams.admin.doc/doc/tags.html">https://www.ibm.com/support/knowledgecenter/en/SSCRJU_4.2.1/com.ibm.streams.admin.doc/doc/tags.html</a> for more details of tags within IBM Streams.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Set of resource tags, initially empty.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>set</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If no resources exist with the required tags then job submission will fail.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9: </span>Support for <a class="reference internal" href="#streamsx.topology.topology.Sink" title="streamsx.topology.topology.Sink"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sink</span></code></a> and <a class="reference internal" href="streamsx.spl.op.html#streamsx.spl.op.Invoke" title="streamsx.spl.op.Invoke"><code class="xref py py-class docutils literal notranslate"><span class="pre">Invoke</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.runtime_id">
<em class="property">property </em><code class="sig-name descname">runtime_id</code><a class="headerlink" href="#streamsx.topology.topology.Stream.runtime_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return runtime identifier.</p>
<p>If <a class="reference internal" href="#streamsx.topology.topology.Stream.name" title="streamsx.topology.topology.Stream.name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">name</span></code></a> is not a valid SPL identifier then the
runtime identifier will be valid SPL identifier that represents <cite>name</cite>.
Otherwise <cite>name</cite> is returned.</p>
<p>The runtime identifier is how the underlying SPL operator
or output port is named in the REST api and trace/log files.</p>
<p>If a topology unique name is supplied when creating a stream then runtime
identifier is fixed regardless of other changes in the topology.</p>
<p>The algorithm to determine the runtime name (for clients that
cannot call this method, for example, remote REST clients gathering
metrics) is as follows.</p>
<p>If the length of <a class="reference internal" href="#streamsx.topology.topology.Stream.name" title="streamsx.topology.topology.Stream.name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">name</span></code></a> is less than or equal
to 80 and <code class="docutils literal notranslate"><span class="pre">name</span></code> is an SPL identifier then <code class="docutils literal notranslate"><span class="pre">name</span></code> is used.
An SPL identifier consists only of the characters <code class="docutils literal notranslate"><span class="pre">A-Z</span></code>, <code class="docutils literal notranslate"><span class="pre">a-z</span></code>
<code class="docutils literal notranslate"><span class="pre">0-9</span></code> and <code class="docutils literal notranslate"><span class="pre">_</span></code>, must not start with <code class="docutils literal notranslate"><span class="pre">0-9</span></code> and must not be
an SPL keyword.</p>
<p>Otherwise the identifier has the form <code class="docutils literal notranslate"><span class="pre">prefix_suffix</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">prefix</span></code> is the kind of the SPL operator stripped of
its namespace and <code class="docutils literal notranslate"><span class="pre">::</span></code>.  For all functional methods
the operator kind is the method name with the first
character upper-cased.</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">Filter</span></code> for <a class="reference internal" href="#streamsx.topology.topology.Stream.filter" title="streamsx.topology.topology.Stream.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">Beacon</span></code> for
<code class="docutils literal notranslate"><span class="pre">spl::utility::Beacon</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">suffix</span></code> is a hashed version of name, an MD5 digest
<code class="docutils literal notranslate"><span class="pre">d</span></code> is calculated from the UTf-8 encoding of <code class="docutils literal notranslate"><span class="pre">name</span></code>.
<code class="docutils literal notranslate"><span class="pre">d</span></code> is shortened by having its first eight bytes xor folded
with its last eight bytes. <code class="docutils literal notranslate"><span class="pre">d</span></code> is then base64 encoded
to produce a string. Padding <code class="docutils literal notranslate"><span class="pre">=</span></code> and <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">/</span></code> characters
are removed from the string.</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">s.filter(lambda</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">True,</span> <span class="pre">name='你好')</span></code>
results in a runtime identifier of <code class="docutils literal notranslate"><span class="pre">Filter_oGwCfhWRg4</span></code>.</p>
<p>The default mapping can be overridden by setting <a class="reference internal" href="#streamsx.topology.topology.Topology.name_to_runtime_id" title="streamsx.topology.topology.Topology.name_to_runtime_id"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Topology.name_to_runtime_id</span></code></a> to a callable that returns a valid identifier for its single argument. The returned identifier should be unique with the topology. For example usinig a pre-populated <cite>dict</cite> as the mapper:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
<span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;你好&#39;</span><span class="p">,</span> <span class="s1">&#39;Buses&#39;</span><span class="p">,</span> <span class="s1">&#39;培养&#39;</span><span class="p">:</span><span class="s1">&#39;Trains&#39;</span><span class="p">}</span>
<span class="n">topo</span><span class="o">.</span><span class="n">name_to_runtime_id</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">get</span>

<span class="n">buses</span> <span class="o">=</span> <span class="n">toopo</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;你好&#39;</span><span class="p">)</span>
<span class="n">trains</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;培养&#39;</span><span class="p">}</span>

<span class="o">//</span> <span class="n">buses</span><span class="o">.</span><span class="n">runtime_id</span> <span class="n">will</span> <span class="n">be</span> <span class="n">Buses</span>
<span class="o">//</span> <span class="n">trains</span><span class="o">.</span><span class="n">runtime_id</span> <span class="n">will</span> <span class="n">be</span> <span class="n">Trains</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Runtime identifier of the stream.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.14.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.set_consistent">
<code class="sig-name descname">set_consistent</code><span class="sig-paren">(</span><em class="sig-param">consistent_config</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.set_consistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates that the stream is the start of a consistent region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>consistent_config</strong> (<em>consistent.ConsistentRegionConfig</em>) – the configuration of the consistent region.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Returns this stream.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream">Stream</a></p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.11.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.set_parallel">
<code class="sig-name descname">set_parallel</code><span class="sig-paren">(</span><em class="sig-param">width</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.set_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Set this source stream to be split into multiple channels
as the start of a parallel region.</p>
<p>Calling <code class="docutils literal notranslate"><span class="pre">set_parallel</span></code> on a stream created by
<a class="reference internal" href="#streamsx.topology.topology.Topology.source" title="streamsx.topology.topology.Topology.source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">source()</span></code></a> results in the stream
having <cite>width</cite> channels, each created by its own instance
of the callable:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">S</span><span class="p">())</span>
<span class="n">s</span><span class="o">.</span><span class="n">set_parallel</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">F</span><span class="p">())</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">end_parallel</span><span class="p">()</span>
</pre></div>
</div>
<p>Each channel has independent instances of <code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">F</span></code>. Tuples
created by the instance of <code class="docutils literal notranslate"><span class="pre">S</span></code> in channel 0 are passed to the
instance of <code class="docutils literal notranslate"><span class="pre">F</span></code> in channel 0, and so on for channels 1 and 2.</p>
<p>Callable transforms instances within the channel can use
the runtime functions
<a class="reference internal" href="streamsx.ec.html#streamsx.ec.channel" title="streamsx.ec.channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">channel()</span></code></a>,
<a class="reference internal" href="streamsx.ec.html#streamsx.ec.local_channel" title="streamsx.ec.local_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">local_channel()</span></code></a>,
<a class="reference internal" href="streamsx.ec.html#streamsx.ec.max_channels" title="streamsx.ec.max_channels"><code class="xref py py-func docutils literal notranslate"><span class="pre">max_channels()</span></code></a> &amp;
<a class="reference internal" href="streamsx.ec.html#streamsx.ec.local_max_channels" title="streamsx.ec.local_max_channels"><code class="xref py py-func docutils literal notranslate"><span class="pre">local_max_channels()</span></code></a>
to adapt to being invoked in parallel. For example a
source callable can use its channel number to determine
which partition to read from in a partitioned external system.</p>
<p>Calling <code class="docutils literal notranslate"><span class="pre">set_parallel</span></code> on a stream created by
<a class="reference internal" href="#streamsx.topology.topology.Topology.subscribe" title="streamsx.topology.topology.Topology.subscribe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subscribe()</span></code></a> results in the stream
having <cite>width</cite> channels. Subscribe ensures that the
stream will contain all published tuples matching the
topic subscription and type. A published tuple will appear
on one of the channels though the specific channel is not known
in advance.</p>
<p>A parallel region is terminated by <a class="reference internal" href="#streamsx.topology.topology.Stream.end_parallel" title="streamsx.topology.topology.Stream.end_parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">end_parallel()</span></code></a>
or <a class="reference internal" href="#streamsx.topology.topology.Stream.for_each" title="streamsx.topology.topology.Stream.for_each"><code class="xref py py-meth docutils literal notranslate"><span class="pre">for_each()</span></code></a>.</p>
<p>The number of channels is set by <cite>width</cite> which may be an <cite>int</cite> greater
than zero or a submission parameter created by
<a class="reference internal" href="#streamsx.topology.topology.Topology.create_submission_parameter" title="streamsx.topology.topology.Topology.create_submission_parameter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Topology.create_submission_parameter()</span></code></a>.</p>
<p>With IBM Streams 4.3 or later the number of channels can be
dynamically changed at runtime.</p>
<p>Parallel regions are started on non-source streams using
<a class="reference internal" href="#streamsx.topology.topology.Stream.parallel" title="streamsx.topology.topology.Stream.parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parallel()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>width</strong> (int|submission parameter created by <a class="reference internal" href="#streamsx.topology.topology.Topology.create_submission_parameter" title="streamsx.topology.topology.Topology.create_submission_parameter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Topology.create_submission_parameter()</span></code></a>) – The degree of parallelism for the parallel region.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of the parallel region. Defaults to the name of this stream.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Returns this stream.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream">Stream</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#streamsx.topology.topology.Stream.parallel" title="streamsx.topology.topology.Stream.parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parallel()</span></code></a>, <a class="reference internal" href="#streamsx.topology.topology.Stream.end_parallel" title="streamsx.topology.topology.Stream.end_parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">end_parallel()</span></code></a></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.11: </span><cite>name</cite> parameter added.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.split">
<code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param">into</em>, <em class="sig-param">func</em>, <em class="sig-param">names=None</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits tuples from this stream into multiple independent streams
using the supplied callable <cite>func</cite>.</p>
<p>For each tuple on the stream <code class="docutils literal notranslate"><span class="pre">int(func(tuple))</span></code> is called, if the
return is zero or positive then the (unmodified) tuple will be
present on one, and only one, of the output streams.
The specific stream will
be at index <code class="docutils literal notranslate"><span class="pre">int(func(tuple))</span> <span class="pre">%</span> <span class="pre">N</span></code> in the returned list,
where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the number of output
streams. If the return is negative then the tuple is dropped.</p>
<p><code class="docutils literal notranslate"><span class="pre">split</span></code> is used to declare disparate transforms on each
split stream. This differs to <a class="reference internal" href="#streamsx.topology.topology.Stream.parallel" title="streamsx.topology.topology.Stream.parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parallel()</span></code></a> where
each channel has the same logic transforms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>into</strong> (<em>int</em>) – Number of streams the input is split into, must be greater than zero.</p></li>
<li><p><strong>func</strong> – Split callable that takes a single parameter for the tuple.</p></li>
<li><p><strong>names</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – Names of the returned streams, in order. If not supplied or a stream doesn’t have an entry in <cite>names</cite> then a generated name is used. Entries are used to generated the field names of the returned named tuple.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of the split transform, defaults to a generated name.</p></li>
</ul>
</dd>
</dl>
<p>If invoking <code class="docutils literal notranslate"><span class="pre">func</span></code> for a tuple on the stream raises an exception
then its processing element will terminate. By default the processing
element will automatically restart though tuples may be lost.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">func</span></code> is a callable object then it may suppress exceptions
by return a true value from its <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> method. When an
exception is suppressed no tuple is submitted to the filtered
stream corresponding to the input tuple that caused the exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Named tuple of streams this stream is split across. All returned streams have the same schema as this stream.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>namedtuple</p>
</dd>
</dl>
<p class="rubric">Type hints</p>
<p>The argument type hint on <cite>func</cite> is used (if present) to verify
at topology declaration time that it is compatible with the
type of tuples on this stream.</p>
<p class="rubric">Examples</p>
<p>Example of splitting a stream based upon message severity, dropping
any messages with unknown severity, and then performing different
transforms for each severity:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">msgs</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">ReadMessages</span><span class="p">())</span>
<span class="n">SEVS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}</span>
<span class="n">severities</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">SEVS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;SEV&#39;</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;high&#39;</span><span class="p">,</span><span class="s1">&#39;medium&#39;</span><span class="p">,</span><span class="s1">&#39;low&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;SeveritySplit&#39;</span><span class="p">)</span>

<span class="n">high_severity</span> <span class="o">=</span> <span class="n">severities</span><span class="o">.</span><span class="n">high</span>
<span class="n">high_severity</span><span class="o">.</span><span class="n">for_each</span><span class="p">(</span><span class="n">SendAlert</span><span class="p">())</span>

<span class="n">medium_severity</span> <span class="o">=</span> <span class="n">severities</span><span class="o">.</span><span class="n">medium</span>
<span class="n">medium_severity</span><span class="o">.</span><span class="n">for_each</span><span class="p">(</span><span class="n">LogMessage</span><span class="p">())</span>

<span class="n">low_severity</span> <span class="o">=</span> <span class="n">severities</span><span class="o">.</span><span class="n">low</span>
<span class="n">low_severity</span><span class="o">.</span><span class="n">for_each</span><span class="p">(</span><span class="n">Archive</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#streamsx.topology.topology.Stream.parallel" title="streamsx.topology.topology.Stream.parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parallel()</span></code></a></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.13.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.union">
<code class="sig-name descname">union</code><span class="sig-paren">(</span><em class="sig-param">streamSet</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a stream that is a union of this stream and other streams</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>streamSet</strong> – a set of Stream objects to merge with this stream</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream">Stream</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Stream.view">
<code class="sig-name descname">view</code><span class="sig-paren">(</span><em class="sig-param">buffer_time=10.0</em>, <em class="sig-param">sample_size=10000</em>, <em class="sig-param">name=None</em>, <em class="sig-param">description=None</em>, <em class="sig-param">start=False</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Stream.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a view on a stream.</p>
<p>A view is a continually updated sampled buffer of a streams’s tuples.
Views allow visibility into a stream from external clients such
as Jupyter Notebooks, the Streams console,
<a class="reference external" href="https://www.ibm.com/support/knowledgecenter/SSCRJU_4.2.0/com.ibm.streams.excel.doc/doc/excel_overview.html">Microsoft Excel</a> or REST clients.</p>
<p>The view created by this method can be used by external clients
and through the returned <a class="reference internal" href="#streamsx.topology.topology.View" title="streamsx.topology.topology.View"><code class="xref py py-class docutils literal notranslate"><span class="pre">View</span></code></a> object after the topology is submitted. For example a Jupyter Notebook can
declare and submit an application with views, and then
use the resultant <cite>View</cite> objects to visualize live data within the streams.</p>
<p>When the stream contains Python objects then they are converted
to JSON.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>buffer_time</strong> – Specifies the buffer size to use measured in seconds.</p></li>
<li><p><strong>sample_size</strong> – Specifies the number of tuples to sample per second.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of the view. Name must be unique within the topology. Defaults to a generated name.</p></li>
<li><p><strong>description</strong> – Description of the view.</p></li>
<li><p><strong>start</strong> (<em>bool</em>) – Start buffering data when the job is submitted.
If <cite>False</cite> then the view starts buffering data when the first
remote client accesses it to retrieve data.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>View object which can be used to access the data when the
topology is submitted.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#streamsx.topology.topology.View" title="streamsx.topology.topology.View">streamsx.topology.topology.View</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Views are only supported when submitting to distributed
contexts including Streaming Analytics service.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="streamsx.topology.topology.View">
<em class="property">class </em><code class="sig-prename descclassname">streamsx.topology.topology.</code><code class="sig-name descname">View</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.View" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The View class provides access to a continuously updated sampling of data items on a <a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> after submission.
A view object is produced by <a class="reference internal" href="#streamsx.topology.topology.Stream.view" title="streamsx.topology.topology.Stream.view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">view()</span></code></a>, and will access data items from the stream on which it is invoked.</p>
<p>For example, a <cite>View</cite> object could be created and used as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">topology</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rands</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">iter</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">view</span> <span class="o">=</span> <span class="n">rands</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">submit</span><span class="p">(</span><span class="n">ContextTypes</span><span class="o">.</span><span class="n">DISTRIBUTED</span><span class="p">,</span> <span class="n">topology</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">start_data_fetch</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="mi">60</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0.6527</span>
<span class="go">0.1963</span>
<span class="go">0.0512</span>
</pre></div>
</div>
<dl class="method">
<dt id="streamsx.topology.topology.View.display">
<code class="sig-name descname">display</code><span class="sig-paren">(</span><em class="sig-param">duration=None</em>, <em class="sig-param">period=2</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.View.display" title="Permalink to this definition">¶</a></dt>
<dd><p>Display a view within a Jupyter or IPython notebook.</p>
<p>Provides an easy mechanism to visualize data on a stream
using a view.</p>
<p>Tuples are fetched from the view and displayed in a table
within the notebook cell using a <code class="docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>.
The table is continually updated with the latest tuples from the view.</p>
<p>This method calls <a class="reference internal" href="#streamsx.topology.topology.View.start_data_fetch" title="streamsx.topology.topology.View.start_data_fetch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start_data_fetch()</span></code></a> and will call
<a class="reference internal" href="#streamsx.topology.topology.View.stop_data_fetch" title="streamsx.topology.topology.View.stop_data_fetch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop_data_fetch()</span></code></a> when completed if <cite>duration</cite> is set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>duration</strong> (<em>float</em>) – Number of seconds to fetch and display tuples. If <code class="docutils literal notranslate"><span class="pre">None</span></code> then the display will be updated until <a class="reference internal" href="#streamsx.topology.topology.View.stop_data_fetch" title="streamsx.topology.topology.View.stop_data_fetch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop_data_fetch()</span></code></a> is called.</p></li>
<li><p><strong>period</strong> (<em>float</em>) – Maximum update period.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A view is a sampling of data on a stream so tuples that
are on the stream may not appear in the view.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Python modules <cite>ipywidgets</cite> and <cite>pandas</cite> must be installed
in the notebook environment.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Behavior when called outside a notebook is undefined.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.View.fetch_tuples">
<code class="sig-name descname">fetch_tuples</code><span class="sig-paren">(</span><em class="sig-param">max_tuples=20</em>, <em class="sig-param">timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.View.fetch_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch a number of tuples from this view.</p>
<p>Fetching of data must have been started with
<a class="reference internal" href="#streamsx.topology.topology.View.start_data_fetch" title="streamsx.topology.topology.View.start_data_fetch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start_data_fetch()</span></code></a> before calling this method.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">timeout</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> then the returned list will
contain <code class="docutils literal notranslate"><span class="pre">max_tuples</span></code> tuples. Otherwise if the timeout is reached
the list may contain less than <code class="docutils literal notranslate"><span class="pre">max_tuples</span></code> tuples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_tuples</strong> (<em>int</em>) – Maximum number of tuples to fetch.</p></li>
<li><p><strong>timeout</strong> (<em>float</em>) – Maximum time to wait for <code class="docutils literal notranslate"><span class="pre">max_tuples</span></code> tuples.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List of fetched tuples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.View.start_data_fetch">
<code class="sig-name descname">start_data_fetch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.View.start_data_fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts a background thread which begins accessing data from the remote Stream.
The data items are placed asynchronously in a queue, which is returned from this method.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A Queue object which is populated with the data items of the stream.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>queue.Queue</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.View.stop_data_fetch">
<code class="sig-name descname">stop_data_fetch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.View.stop_data_fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Terminates the background thread fetching stream data items.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="streamsx.topology.topology.PendingStream">
<em class="property">class </em><code class="sig-prename descclassname">streamsx.topology.topology.</code><code class="sig-name descname">PendingStream</code><span class="sig-paren">(</span><em class="sig-param">topology</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.PendingStream" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Pending stream connection.</p>
<p>A pending stream is an initially <cite>disconnected</cite> stream. The <cite>stream</cite> attribute
can be used as an input stream when the required stream is not yet available. Once the required
stream is available the connection is made using <a class="reference internal" href="#streamsx.topology.topology.PendingStream.complete" title="streamsx.topology.topology.PendingStream.complete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">complete()</span></code></a>.</p>
<p>The schema of the pending stream is defined by the stream passed into <cite>complete</cite>.</p>
<p>A simple example is creating a source stream after the filter that will use it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the pending or placeholder stream</span>
<span class="n">pending_source</span> <span class="o">=</span> <span class="n">PendingStream</span><span class="p">(</span><span class="n">topology</span><span class="p">)</span>

<span class="c1"># Create a filter against the placeholder stream</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">pending_source</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">t</span> <span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">))</span>

<span class="n">source</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="n">source</span><span class="p">([</span><span class="s1">&#39;Hello&#39;</span><span class="p">,</span> <span class="s1">&#39;World&#39;</span><span class="p">])</span>

<span class="c1"># Now complete the connection</span>
<span class="n">pending_source</span><span class="o">.</span><span class="n">complete</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
</pre></div>
</div>
<p>Streams allows feedback loops in its flow graphs, where downstream processing can produce a stream that is
fed back into the input port of an upstream operator. Typically, feedback loops are
used to modify the state of upstream transformations, rather than repeat processing of tuples.</p>
<p>A feedback loop can be created by using a <cite>PendingStream</cite>. The upstream transformation or operator
that will end the feedback loop uses <code class="xref py py-attr docutils literal notranslate"><span class="pre">stream</span></code> as one of its inputs. A processing
pipeline is then created and once the downstream starting point of the feedback loop is available,
it is passed to <a class="reference internal" href="#streamsx.topology.topology.PendingStream.complete" title="streamsx.topology.topology.PendingStream.complete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">complete()</span></code></a> to create the loop.</p>
<dl class="method">
<dt id="streamsx.topology.topology.PendingStream.complete">
<code class="sig-name descname">complete</code><span class="sig-paren">(</span><em class="sig-param">stream</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.PendingStream.complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete the pending stream.</p>
<p>Any connections made to <code class="xref py py-attr docutils literal notranslate"><span class="pre">stream</span></code> are connected to <cite>stream</cite> once
this method returns.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>stream</strong> (<a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream"><em>Stream</em></a>) – Stream that completes the connection.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.PendingStream.is_complete">
<code class="sig-name descname">is_complete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.PendingStream.is_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Has this connection been completed.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="streamsx.topology.topology.Window">
<em class="property">class </em><code class="sig-prename descclassname">streamsx.topology.topology.</code><code class="sig-name descname">Window</code><span class="sig-paren">(</span><em class="sig-param">stream</em>, <em class="sig-param">window_type</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Window" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Declaration of a window of tuples on a <cite>Stream</cite>.</p>
<p>A <cite>Window</cite> enables transforms against collection (or window)
of tuples on a stream rather than per-tuple transforms.
Windows are created against a stream using <a class="reference internal" href="#streamsx.topology.topology.Stream.batch" title="streamsx.topology.topology.Stream.batch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Stream.batch()</span></code></a>
or <a class="reference internal" href="#streamsx.topology.topology.Stream.last" title="streamsx.topology.topology.Stream.last"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Stream.last()</span></code></a>.</p>
<p>Supported transforms are:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#streamsx.topology.topology.Window.aggregate" title="streamsx.topology.topology.Window.aggregate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aggregate()</span></code></a> - Aggregate the window contents into a single tuple.</p></li>
</ul>
</div></blockquote>
<p>A window is optionally <a class="reference internal" href="#streamsx.topology.topology.Window.partition" title="streamsx.topology.topology.Window.partition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">partitioned</span></code></a> to create
independent sub-windows per partition key.</p>
<p>A <cite>Window</cite> can be also passed as the input of an SPL
operator invocation to indicate the operator’s
input port is windowed.</p>
<p>Example invoking the SPL <cite>Aggregate</cite> operator with a sliding window of
the last two minutes, triggering every five tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">win</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">trigger</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="n">agg</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="s1">&#39;spl.relational::Aggregate&#39;</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span>
            <span class="n">schema</span> <span class="o">=</span> <span class="s1">&#39;tuple&lt;uint64 sum, uint64 max&gt;&#39;</span><span class="p">)</span>
<span class="n">agg</span><span class="o">.</span><span class="n">sum</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="s1">&#39;Sum(val)&#39;</span><span class="p">)</span>
<span class="n">agg</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="s1">&#39;Max(val)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="streamsx.topology.topology.Window.aggregate">
<code class="sig-name descname">aggregate</code><span class="sig-paren">(</span><em class="sig-param">function</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Window.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregates the contents of the window when the window is
triggered.</p>
<p>Upon a window trigger, the supplied function is passed a list containing
the contents of the window: <code class="docutils literal notranslate"><span class="pre">function(items)</span></code>. The order of the window
items in the list are the order in which they were each received by the
window. If the function’s return value is not <cite>None</cite> then the result will
be submitted as a tuple on the returned stream. If the return value is
<cite>None</cite> then no tuple submission will occur.</p>
<p>For example, a window that calculates a moving average of the
last 10 tuples could be written as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">win</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">trigger</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">moving_averages</span> <span class="o">=</span> <span class="n">win</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="k">lambda</span> <span class="n">tuples</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">tuples</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">tuples</span><span class="p">))</span>
</pre></div>
</div>
<p>When the window is <a class="reference internal" href="#streamsx.topology.topology.Window.partition" title="streamsx.topology.topology.Window.partition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">partitioned</span></code></a>
then each partition is triggered and aggregated using
<cite>function</cite> independently.</p>
<p>For example, this partitioned window aggregation will independently
call <code class="docutils literal notranslate"><span class="pre">summarize_sensors</span></code> with ten tuples all having the same <cite>id</cite>
when triggered. Each partition triggers independently so that
<code class="docutils literal notranslate"><span class="pre">summarize_sensors</span></code> is invoked for a specific <cite>id</cite> every time
two tuples with that <cite>id</cite> have been inserted into the window partition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">win</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">trigger</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="n">moving_averages</span> <span class="o">=</span> <span class="n">win</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">summarize_sensors</span><span class="p">)</span>
</pre></div>
</div>
<p>Example for building a rolling average window aggregation with stream tuples passed as a <cite>named tuple</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">streamsx.topology.topology</span> <span class="k">import</span> <span class="n">Topology</span>
<span class="kn">from</span> <span class="nn">streamsx.topology</span> <span class="k">import</span> <span class="n">context</span>
<span class="kn">from</span> <span class="nn">streamsx.topology.context</span> <span class="k">import</span> <span class="n">submit</span><span class="p">,</span> <span class="n">ContextTypes</span><span class="p">,</span> <span class="n">ConfigParams</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">NamedTuple</span>

<span class="k">class</span> <span class="nc">AggregateSchema</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">avg</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="nb">min</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nb">max</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">class</span> <span class="nc">Average</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tuples_in_window</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AggregateSchema</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">tpl</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">tpl</span> <span class="ow">in</span> <span class="n">tuples_in_window</span><span class="p">]</span>
        <span class="n">mn</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">num_of_tuples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tuples_in_window</span><span class="p">)</span>
        <span class="n">average</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">tuples_in_window</span><span class="p">)</span>
        <span class="n">output_event</span> <span class="o">=</span> <span class="n">AggregateSchema</span><span class="p">(</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">num_of_tuples</span><span class="p">,</span>
            <span class="n">avg</span> <span class="o">=</span> <span class="n">average</span><span class="p">,</span>
            <span class="nb">min</span> <span class="o">=</span> <span class="n">mn</span><span class="p">,</span>
            <span class="nb">max</span> <span class="o">=</span> <span class="n">mx</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">output_event</span>

<span class="k">class</span> <span class="nc">NumbersSchema</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">class</span> <span class="nc">Numbers</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">NumbersSchema</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">yield</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">num</span><span class="p">}</span>

<span class="n">topo</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">(</span><span class="s2">&quot;Rolling Average&quot;</span><span class="p">)</span>
<span class="n">src</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">Numbers</span><span class="p">())</span>
<span class="c1"># sliding window with eviction count as submission parameter</span>
<span class="n">window</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">topo</span><span class="o">.</span><span class="n">create_submission_parameter</span><span class="p">(</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">rolling_average</span> <span class="o">=</span> <span class="n">window</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">Average</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a tumbling (<a class="reference internal" href="#streamsx.topology.topology.Stream.batch" title="streamsx.topology.topology.Stream.batch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">batch()</span></code></a>) window’s stream
is finite then a final aggregation is performed if the
window is not empty. Thus <code class="docutils literal notranslate"><span class="pre">function</span></code> may be passed fewer tuples
for a window sized using a count. For example a stream with 105
tuples and a batch size of 25 tuples will perform four aggregations
with 25 tuples each and a final aggregation of 5 tuples.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> – The function which aggregates the contents of the window</p></li>
<li><p><strong>name</strong> (<em>str</em>) – The name of the returned stream. Defaults to a generated name.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Stream</cite> of the returned values of the supplied function.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream">Stream</a></p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In Python 3.5 or later if the stream being aggregated has a
structured schema that contains a <code class="docutils literal notranslate"><span class="pre">blob</span></code> type then any <code class="docutils literal notranslate"><span class="pre">blob</span></code>
value will not be maintained in the window. Instead its
<code class="docutils literal notranslate"><span class="pre">memoryview</span></code> object will have been released. If the <code class="docutils literal notranslate"><span class="pre">blob</span></code>
value is required then perform a <code class="xref py py-meth docutils literal notranslate"><span class="pre">map()</span></code> transformation
(without setting <code class="docutils literal notranslate"><span class="pre">schema</span></code>) copying any required
blob value in the tuple using <code class="docutils literal notranslate"><span class="pre">memoryview.tobytes()</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.11: </span>Support for aggregation of streams with structured schemas.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.13: </span>Support for partitioned aggregation.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Window.partition">
<code class="sig-name descname">partition</code><span class="sig-paren">(</span><em class="sig-param">key</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Window.partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare a window with this window’s eviction and trigger policies, and a partition.</p>
<p>In a partitioned window, a subwindow will be created for each distinct
value received for the attribute used for partitioning.  Each subwindow
is treated as if it were a separate window, and each subwindow shares
the same trigger and eviction policy.</p>
<p>The key may either be a string containing the name of an attribute,
or a python callable.</p>
<p>The <cite>key</cite> parameter may be a string only with a structured schema,
and the value of the <cite>key</cite> parameter must be the name of a single
attribute in the schema.</p>
<p>The <cite>key</cite> parameter may be a python callable object.  If it is, the
callable is evaluated for each tuple, and the return from the callable
determines the partition into which the tuple is placed.  The return
value must have a <code class="docutils literal notranslate"><span class="pre">__hash__</span></code> method.  If checkpointing is enabled,
and the callable object has a state, the state of the callable object
will be saved and restored in checkpoints.  However, <code class="docutils literal notranslate"><span class="pre">__enter__</span></code> and
<code class="docutils literal notranslate"><span class="pre">__exit__</span></code> methods may not be called on the callable object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>key</strong> – The name of the attribute to be used for partitioning, or
the python callable object used for partitioning.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Window that will be triggered.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#streamsx.topology.topology.Window" title="streamsx.topology.topology.Window">Window</a></p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.13.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Window.trigger">
<code class="sig-name descname">trigger</code><span class="sig-paren">(</span><em class="sig-param">when=1</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Window.trigger" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare a window with this window’s size and a trigger policy.</p>
<p>When the window is triggered is defined by <cite>when</cite>.</p>
<p>If <cite>when</cite> is an <cite>int</cite> then the window is triggered every
<cite>when</cite> tuples.  For example, with <code class="docutils literal notranslate"><span class="pre">when=5</span></code> the window
will be triggered every five tuples.</p>
<p>If <cite>when</cite> is an <cite>datetime.timedelta</cite> then it is the period
of the trigger. With a <cite>timedelta</cite> representing one minute
then the window is triggered every minute.</p>
<p>By default, when <cite>trigger</cite> has not been called on a <cite>Window</cite>
it triggers for every tuple inserted into the window
(equivalent to <code class="docutils literal notranslate"><span class="pre">when=1</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>when</strong> – The size of the window, either an <cite>int</cite> to define the
number of tuples or <cite>datetime.timedelta</cite> to define the
duration of the window.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Window that will be triggered.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#streamsx.topology.topology.Window" title="streamsx.topology.topology.Window">Window</a></p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>A trigger is only supported for a sliding window
such as one created by <code class="xref py py-meth docutils literal notranslate"><span class="pre">last()</span></code>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="streamsx.topology.topology.Sink">
<em class="property">class </em><code class="sig-prename descclassname">streamsx.topology.topology.</code><code class="sig-name descname">Sink</code><span class="sig-paren">(</span><em class="sig-param">op</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Sink" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">streamsx._streams._placement._Placement</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Termination of a <cite>Stream</cite>.</p>
<p>A <a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> is terminated by processing that typically
sends the tuples to an external system.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A <cite>Stream</cite> may have multiple terminations.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#streamsx.topology.topology.Stream.for_each" title="streamsx.topology.topology.Stream.for_each"><code class="xref py py-meth docutils literal notranslate"><span class="pre">for_each()</span></code></a>, <a class="reference internal" href="#streamsx.topology.topology.Stream.publish" title="streamsx.topology.topology.Stream.publish"><code class="xref py py-meth docutils literal notranslate"><span class="pre">publish()</span></code></a>, <a class="reference internal" href="#streamsx.topology.topology.Stream.print" title="streamsx.topology.topology.Stream.print"><code class="xref py py-meth docutils literal notranslate"><span class="pre">print()</span></code></a></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.</span></p>
</div>
<dl class="method">
<dt id="streamsx.topology.topology.Sink.category">
<em class="property">property </em><code class="sig-name descname">category</code><a class="headerlink" href="#streamsx.topology.topology.Sink.category" title="Permalink to this definition">¶</a></dt>
<dd><p>Category for this processing logic.</p>
<p>An arbitrary application label allowing grouping of application
elements by category.</p>
<p>Assign categories based on common function.
For example, <cite>database</cite> is a common category that you can
use to group all database sinks in an application.</p>
<p>A category is not required and defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code> meaning
no assigned category.</p>
<p>Streams console supports visualization based upon categories.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>TypeError</strong> – No directly associated processing logic.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A category has no affect on the execution of the application.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Sink.colocate">
<code class="sig-name descname">colocate</code><span class="sig-paren">(</span><em class="sig-param">others</em><span class="sig-paren">)</span><a class="headerlink" href="#streamsx.topology.topology.Sink.colocate" title="Permalink to this definition">¶</a></dt>
<dd><p>Colocate this processing logic with others.</p>
<p>Colocating processing logic requires execution in
the same Streams processing element (operating system process).</p>
<p>When a job is submitted Streams may colocate (fuse) processing
logic into the same processing element based upon flow analysis
and current resource usage. This call instructs that this logic
and <cite>others</cite> must be executed in the same processing element.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>others</strong> – Processing logic such as a
<a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>
or <a class="reference internal" href="#streamsx.topology.topology.Sink" title="streamsx.topology.topology.Sink"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sink</span></code></a>.
A single value can be passed or an iterable, such
as a list of streams.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>This logic.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamsx.topology.topology.Sink.resource_tags">
<em class="property">property </em><code class="sig-name descname">resource_tags</code><a class="headerlink" href="#streamsx.topology.topology.Sink.resource_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource tags for this processing logic.</p>
<p>Tags are a mechanism for differentiating and identifying resources that have different physical characteristics or logical uses. For example a resource (host) that has external connectivity for public data sources may be tagged <cite>ingest</cite>.</p>
<p>Processing logic can be associated with one or more tags to require
running on suitably tagged resources. For example
adding tags <cite>ingest</cite> and <cite>db</cite> requires that the processing element
containing the callable that created the stream runs on a host
tagged with both <cite>ingest</cite> and <cite>db</cite>.</p>
<p>A <a class="reference internal" href="#streamsx.topology.topology.Stream" title="streamsx.topology.topology.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> that was not created directly with a Python callable
cannot have tags associated with it. For example a stream that
is a <a class="reference internal" href="#streamsx.topology.topology.Stream.union" title="streamsx.topology.topology.Stream.union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">union()</span></code></a> of multiple streams cannot be tagged.
In this case this method returns an empty <cite>frozenset</cite> which
cannot be modified.</p>
<p>See <a class="reference external" href="https://www.ibm.com/support/knowledgecenter/en/SSCRJU_4.2.1/com.ibm.streams.admin.doc/doc/tags.html">https://www.ibm.com/support/knowledgecenter/en/SSCRJU_4.2.1/com.ibm.streams.admin.doc/doc/tags.html</a> for more details of tags within IBM Streams.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Set of resource tags, initially empty.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>set</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If no resources exist with the required tags then job submission will fail.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9: </span>Support for <a class="reference internal" href="#streamsx.topology.topology.Sink" title="streamsx.topology.topology.Sink"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sink</span></code></a> and <a class="reference internal" href="streamsx.spl.op.html#streamsx.spl.op.Invoke" title="streamsx.spl.op.Invoke"><code class="xref py py-class docutils literal notranslate"><span class="pre">Invoke</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="streamsx.topology.context.html" class="btn btn-neutral float-right" title="streamsx.topology.context" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="streamsx.topology.html" class="btn btn-neutral float-left" title="streamsx.topology" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015,2020 IBM Corp.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>